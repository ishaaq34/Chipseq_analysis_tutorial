<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ChIP-seq Analysis Tutorial </title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom-7f17e3e7.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-5db23b83.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-9c36ea23.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">ChIP-seq Analysis Tutorial </h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="welcome-to-the-practical-chip-seq-tutorial"><a class="header" href="#welcome-to-the-practical-chip-seq-tutorial">Welcome to the Practical ChIP-seq Tutorial</a></h1>
<p><code>ChIP-seq</code> <code>chromatin-immunoprecipitation</code> <code>epigenetics</code> <code>genome-wide-binding</code> <code>transcription-factors</code> <code>histone-modifications</code> <code>NGS</code> <code>introduction</code></p>
<h2 id="1-what-is-chip-seq"><a class="header" href="#1-what-is-chip-seq">1. What is ChIP-seq?</a></h2>
<p>ChIP-seq (Chromatin Immunoprecipitation followed by sequencing) answers one key question: <strong>Where do proteins interact with DNA in our genome?</strong></p>
<p>Think of your genome as a massive library with 3 billion books. Certain proteins act as “bookmarks” that control which genes are active. ChIP-seq lets us find all these bookmarks at once, across the entire genome.</p>
<p>By mapping these binding locations, we learn how genes are turned on and off—knowledge that is critical for understanding both normal biology and diseases like cancer.</p>
<hr>
<h2 id="2-a-brief-history--why-chip-seq-matters"><a class="header" href="#2-a-brief-history--why-chip-seq-matters">2. A Brief History &amp; Why ChIP-seq Matters</a></h2>
<p>Before ChIP-seq, researchers had limited options for studying protein-DNA interactions. ChIP-PCR could only examine a handful of pre-selected regions—like searching for a word in a book by checking only 10 pages. ChIP-chip improved on this by using microarrays, but it remained constrained to predefined genomic regions and offered limited resolution (<a href="https://www.nature.com/articles/nrg2641">Park, 2009</a>).</p>
<p>The arrival of next-generation sequencing in the mid-2000s changed everything. ChIP-seq enabled genome-wide, high-resolution mapping for the first time, allowing scientists to see the complete picture of protein-DNA interactions across the entire genome.</p>
<p>This breakthrough enabled landmark discoveries. The <a href="https://www.nature.com/articles/nature11247">ENCODE Project (2012)</a> used ChIP-seq extensively to demonstrate that approximately 80% of the human genome has biochemical function—fundamentally overturning the long-held “junk DNA” myth. That same year, researchers used ChIP-seq to reveal <a href="https://www.science.org/doi/10.1126/science.1226339">how our 24-hour body clock is encoded in chromatin</a>, explaining at the molecular level why circadian disruption increases disease risk.</p>
<p>These discoveries demonstrate ChIP-seq’s direct impact on personalized medicine, cancer research, and our understanding of gene regulation.</p>
<hr>
<h2 id="3-how-chip-seq-works-the-experiment"><a class="header" href="#3-how-chip-seq-works-the-experiment">3. How ChIP-seq Works (The Experiment)</a></h2>
<p>A ChIP-seq experiment captures where proteins bind to DNA through five connected steps. First, formaldehyde <strong>cross-links</strong> proteins to DNA, freezing them in place like taking a snapshot. Next, the DNA is <strong>sheared</strong> into small fragments—imagine cutting a long rope into shorter segments that are easier to handle.</p>
<p>The key step is <strong>immunoprecipitation</strong>: antibodies that recognize your protein of interest act like magnets, pulling out only the DNA fragments attached to that specific protein. After this enrichment, <strong>reverse cross-linking</strong> releases the DNA from the proteins, leaving you with purified DNA fragments that were bound by your target. Finally, these fragments are <strong>sequenced</strong>, generating millions of short reads that reveal the genomic locations where your protein was bound (<a href="https://www.nature.com/articles/nrg3306">Furey, 2012</a>).</p>
<hr>
<h2 id="4-computational-analysis-pipeline"><a class="header" href="#4-computational-analysis-pipeline">4. Computational Analysis Pipeline</a></h2>
<p>The millions of reads from Section 3 arrive as data files. Here’s how we process them:</p>
<pre><code class="language-text">FASTQ → BAM → Peaks + BigWig
</code></pre>
<p>After sequencing, you receive data in <strong>FASTQ format</strong>—a text file containing millions of short DNA sequences (= reads), each with a quality score showing how confident we are in each letter (= base call). At this stage, we don’t know <em>where</em> in the genome these sequences came from. That’s what the next step figures out.</p>
<p><strong>Alignment</strong> (= mapping) uses software like <strong>Bowtie2</strong> to match each read to its location on a reference genome. The output is a <strong>SAM file</strong> (Sequence Alignment/Map), which records where each read landed, how well it matched, and other details.</p>
<p>SAM files are plain text and take up a lot of space. So we compress them into <strong>BAM format</strong> (Binary Alignment/Map)—same information, but smaller and faster to work with. In most pipelines, SAM files are never saved; the aligner writes directly to BAM.</p>
<p>Next comes <strong>peak calling</strong>. Tools like <strong>MACS3</strong> scan the BAM file and find regions where reads pile up more than expected—these “peaks” are likely protein binding sites. The output includes peak coordinates and statistical parameters (= p-values, q-values, fold enrichment), saved as <strong>BED files</strong> and <strong>bedGraph files</strong>.</p>
<p><strong>BED files</strong> are simple lists of genomic locations (chromosome, start position, end position). They’re used for many downstream tasks like finding DNA motifs or linking peaks to nearby genes (= annotation).</p>
<p><strong>bedGraph files</strong> are similar to BED files but include a fourth column: a numerical value (like signal intensity or coverage) for each region. This format is human-readable text, useful for inspection, but results in large file sizes for whole-genome data.</p>
<p><strong>BigWig files</strong> contain the same signal information as bedGraph but differ in two key ways:</p>
<ol>
<li><strong>Binary format</strong>: Data is stored in compressed binary rather than plain text, reducing file size significantly</li>
<li><strong>Indexed structure</strong>: An internal index allows software to retrieve data from any genomic region without reading the entire file</li>
</ol>
<p>In practice, this means: when you open a bedGraph in a genome browser, the software must scan from the beginning of the file to find your region of interest. With BigWig, the software uses the index to jump directly to the relevant data block. For a 3-billion-base-pair human genome, this difference makes BigWig the standard format for visualization.</p>
<hr>
<h2 id="5-who-is-this-tutorial-for"><a class="header" href="#5-who-is-this-tutorial-for">5. Who Is This Tutorial For?</a></h2>
<p>This tutorial is designed for:</p>
<ul>
<li><strong>Biology students</strong> new to bioinformatics</li>
<li><strong>Researchers</strong> who want hands-on ChIP-seq analysis skills</li>
<li><strong>Anyone</strong> who prefers learning by doing, not just reading</li>
</ul>
<p><strong>No prior coding experience is required.</strong> We explain every step.</p>
<hr>
<h2 id="6-why-this-tutorial"><a class="header" href="#6-why-this-tutorial">6. Why This Tutorial?</a></h2>
<p>We built this course to solve common frustrations of bioinformatics learning. Here’s what makes it different:</p>
<h3 id="the-tiered-learning-method"><a class="header" href="#the-tiered-learning-method">The “Tiered” Learning Method</a></h3>
<p>We believe you shouldn’t just run code—you should understand it. Every chapter is broken into three levels:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>Focus</th><th>What You’ll Get</th></tr>
</thead>
<tbody>
<tr><td><strong>Level 1: Basic Concept</strong></td><td>The “Why”</td><td>Simple explanations with real-world analogies</td></tr>
<tr><td><strong>Level 2: Execution</strong></td><td>The “How”</td><td>Exact code to run, line-by-line</td></tr>
<tr><td><strong>Level 3: Interpretation</strong></td><td>The “So What?”</td><td>How to read output and spot good vs. bad results</td></tr>
</tbody>
</table>
</div>
<p>By the end, you’ll have the skills—and the code—to analyze your own ChIP-seq data.</p>
<hr>
<h2 id="7-dataset-used-in-this-tutorial"><a class="header" href="#7-dataset-used-in-this-tutorial">7. Dataset Used in This Tutorial</a></h2>
<p>We use two datasets to teach different parts of the pipeline:</p>
<h3 id="part-1-preprocessing-fastq--bam"><a class="header" href="#part-1-preprocessing-fastq--bam">Part 1: Preprocessing (FASTQ → BAM)</a></h3>
<p><strong>Source:</strong> <a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE115704">GSE115704</a> — Histone modifications in <em>C. elegans</em> sperm, oocytes, and early embryos.</p>
<p><strong>Why this dataset?</strong> It’s publicly available and demonstrates the practical steps of downloading, organizing, and aligning raw data.</p>
<h3 id="part-2-downstream-analysis-bam--peaks--visualization"><a class="header" href="#part-2-downstream-analysis-bam--peaks--visualization">Part 2: Downstream Analysis (BAM → Peaks → Visualization)</a></h3>
<p><strong>Source:</strong> <a href="https://www.encodeproject.org/carts/ca521f95-7835-4369-88a9-b89f98fb39ad/">ENCODE BLaER1 data</a> — Human cell line with ChIP-seq for CEBPA, H3K27me3, and H3K9ac.</p>
<p><strong>Why this dataset?</strong> Pre-aligned, high-quality data that lets us focus on peak calling, normalization, and comparative analysis.</p>
<hr>
<h2 id="lets-get-started"><a class="header" href="#lets-get-started">Let’s Get Started</a></h2>
<p>You’re ready to begin. In the next chapter, we’ll set up your computational environment by installing the required tools.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> Before diving into analysis, we’ll set up your computational environment with the bioinformatics tools you’ll need throughout this tutorial.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="setting-up-your-digital-lab-bench-conda-environment"><a class="header" href="#setting-up-your-digital-lab-bench-conda-environment">Setting Up Your Digital Lab Bench (Conda Environment)</a></h1>
<h2 id="basic-concept"><a class="header" href="#basic-concept">Basic Concept</a></h2>
<p>Imagine you are about to start a complex experiment in a wet lab. You wouldn’t just dump all your chemicals and tools onto a cluttered desk, right? You would set up a specific <strong>Lab Bench</strong> with exactly the pipettes, reagents, and machines you need for <em>that specific experiment</em>.</p>
<p>In bioinformatics, <strong>Conda</strong> allows us to do the exact same thing on a computer.</p>
<ul>
<li><strong>The Problem:</strong> Different software tools often conflict with each other (like needing different versions of Python). Installing them all on your main system is like mixing all your chemicals in one bucket—messy and dangerous.</li>
<li><strong>The Solution:</strong> We create a “Virtual Environment” (our digital lab bench). Inside this environment, we install only the tools we need for ChIP-seq. When we are done, we can “close” the environment and go back to a clean computer.</li>
</ul>
<p>In this tutorial, we will build a simplified environment named <code>chip</code> that contains all the tools for our analysis.</p>
<hr>
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<h3 id="step-1-get-the-environment-manager-anaconda"><a class="header" href="#step-1-get-the-environment-manager-anaconda">Step 1: Get the Environment Manager (Anaconda)</a></h3>
<p>First, you need the software that builds these environments. We recommend <strong>Anaconda</strong> (or the lighter version, <strong>Miniconda</strong>).</p>
<ul>
<li>
<p><strong>Check if you already have it:</strong>
Open your terminal and type:</p>
<pre><code class="language-bash">conda --version
</code></pre>
<p><em>(If you see a version number like <code>conda 24.7.1</code>, skip to Step 2.)</em></p>
</li>
<li>
<p><strong>If not, download and install it:</strong></p>
<ul>
<li><strong>Anaconda (Recommended):</strong> <a href="https://www.anaconda.com/download">https://www.anaconda.com/download</a></li>
<li><strong>Miniconda (Lightweight):</strong> <a href="https://docs.conda.io/en/latest/miniconda.html">https://docs.conda.io/en/latest/miniconda.html</a></li>
</ul>
</li>
</ul>
<h3 id="step-2-creates-the-recipe-file"><a class="header" href="#step-2-creates-the-recipe-file">Step 2: Creates the “Recipe” File</a></h3>
<p>To build our lab bench, we give Conda a “recipe” list called a YAML file. This tells Conda exactly which tools to fetch.</p>
<ol>
<li>Create a new file named <code>chip_env.yml</code>.</li>
<li>Copy and paste the exact code below into that file:</li>
</ol>
<pre><code class="language-yaml">name: chip   # Name of our environment
channels:    # The "App Stores" where we find tools
  - bioconda
  - conda-forge
  - bioconda
  - defaults
dependencies: # The tools we want to install
  - multiqc=1.31
  - fastqc=0.12.1
  
</code></pre>
<blockquote>
<p><strong>Note:</strong> If you downloaded the file <a href="https://github.com/ishaaq34/Chipseq_analysis_tutorial/blob/main/Chip.yml">chip.yml</a> . You can use that to install all the tools required for the Chip-seq analysis!</p>
</blockquote>
<h3 id="step-3-build-the-environment"><a class="header" href="#step-3-build-the-environment">Step 3: Build the Environment</a></h3>
<p>Now, let’s look at the instructions to build the bench.</p>
<ol>
<li>
<p><strong>Create the environment:</strong>
Run this command in the same folder where you saved your file:</p>
<pre><code class="language-bash">conda env create -f chip_env.yml
</code></pre>
<p><em>(This takes a few minutes as it downloads all the tools.)</em></p>
</li>
<li>
<p><strong>Enter the environment:</strong>
To start working, you must “step into” your new lab bench:</p>
<pre><code class="language-bash">conda activate chip
</code></pre>
<p><em>(You should see <code>(chip)</code> appear next to your cursor in the terminal.)</em></p>
</li>
</ol>
<h3 id="step-4-verify-your-tools"><a class="header" href="#step-4-verify-your-tools">Step 4: Verify Your Tools</a></h3>
<p>Let’s make sure our tools are actually there. Run these commands:</p>
<pre><code class="language-bash"># Check if key tools are reachable
which fastqc
which bowtie2
which macs3

# Check versions to ensure successful installation
fastqc --version
bowtie2 --version
</code></pre>
<p>If these commands print paths (like <code>/Users/.../envs/chip/bin/fastqc</code>) and version numbers, <strong>congratulations!</strong> Your digital lab bench is ready.</p>
<hr>
<h3 id="understanding-the-yaml-recipe"><a class="header" href="#understanding-the-yaml-recipe">Understanding the YAML “Recipe”</a></h3>
<p>Let’s break down the <code>chip_env.yml</code> file we just used:</p>
<ul>
<li><strong><code>channels</code></strong>: These are repositories (like App Stores).
<ul>
<li><strong><code>bioconda</code></strong>: The community hub for bioinformatics software.</li>
<li><strong><code>conda-forge</code></strong>: A massive collection of general-purpose tools.</li>
<li><em>The order matters!</em> Conda looks in the first channel on the list, then the second.</li>
</ul>
</li>
<li><strong><code>dependencies</code></strong>: This is your shopping list.
<ul>
<li><strong>Version Pinned (e.g., <code>bowtie2=2.5.4</code>)</strong>: We specify the <em>exact</em> version. Why? So that if you run this analysis 2 years from now, you get the exact same results. This is key for <strong>Reproducibility</strong>.</li>
</ul>
</li>
</ul>
<h3 id="managing-your-environment"><a class="header" href="#managing-your-environment">Managing Your Environment</a></h3>
<p>Here are some useful “Housekeeping” commands:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Command</th><th style="text-align: left">Explanation</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>conda deactivate</code></td><td style="text-align: left">“Step out” of the environment. Returns you to your base system.</td></tr>
<tr><td style="text-align: left"><code>conda env list</code></td><td style="text-align: left">Lists all environments you have created on your computer.</td></tr>
<tr><td style="text-align: left"><code>conda env remove -n chip</code></td><td style="text-align: left">Deletes the <code>chip</code> environment mostly used if you made a mistake and want to start over.</td></tr>
<tr><td style="text-align: left"><code>conda env update -f chip_env.yml --prune</code></td><td style="text-align: left">Updates the environment if you change the YAML file. The <code>--prune</code> flag removes old tools you don’t need anymore.</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="summary"><a class="header" href="#summary"><strong>Summary</strong></a></h2>
<ol>
<li><strong>Analogy:</strong> We built a dedicated “Lab Bench” (Environment) to keep our work clean.</li>
<li><strong>Action:</strong> We used <code>conda env create</code> with a YAML recipe to install tools like Bowtie2 and MACS2.</li>
<li><strong>Result:</strong> We now have a <code>(chip)</code> environment ready for the actual ChIP-seq analysis.</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> The tools are installed and waiting. Now we’ll learn Bash scripting to organize and automate our bioinformatics workflow.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bash-automation-your-digital-robot"><a class="header" href="#bash-automation-your-digital-robot">Bash Automation (Your Digital Robot)</a></h1>
<p><code>bash</code> <code>shell-scripting</code> <code>loops</code> <code>automation</code> <code>while-loops</code> <code>for-loops</code> <code>variables</code> <code>command-line</code> <code>batch-processing</code></p>
<h2 id="introduction-why-learn-bash-for-bioinformatics"><a class="header" href="#introduction-why-learn-bash-for-bioinformatics">Introduction: Why Learn Bash for Bioinformatics?</a></h2>
<p><strong>What is Bash?</strong></p>
<p>Bash is a way to control a computer using text commands instead of clicking through menus. It lets you run programs, manage files, and automate tasks by writing simple commands or scripts.</p>
<p><strong>Why is this essential for bioinformatics?</strong></p>
<p>In bioinformatics, you work with large datasets and many specialized tools that must run in a specific sequence. Bash makes these workflows <strong>repeatable</strong> by allowing you to run the same analysis on new data with one command. It keeps them <strong>transparent</strong> so you can see exactly what was done in plain text. Most importantly, Bash workflows are <strong>reliable</strong> because they’re less prone to manual errors from repetitive clicking. Without Bash automation, analyses become harder to track, reproduce, and trust.</p>
<hr>
<h2 id="the-foundation-setting-up-safe-scripts"><a class="header" href="#the-foundation-setting-up-safe-scripts">The Foundation: Setting Up Safe Scripts</a></h2>
<p>Every reliable Bash script should start with these two critical lines:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail
</code></pre>
<p><strong>What do these lines do?</strong></p>
<ol>
<li>
<p><strong><code>#!/bin/bash</code></strong> – This “shebang” line tells your computer to use the Bash shell. It ensures your script behaves the same way on any system.</p>
</li>
<li>
<p><strong><code>set -euo pipefail</code></strong> – This changes Bash’s default behavior from “keep going even if something breaks” to “stop immediately when an error occurs.”</p>
</li>
</ol>
<p>This single choice separates casual scripting from <strong>defensible scientific analysis</strong>. You want your script to fail loudly if something goes wrong, not silently produce incorrect results.</p>
<p><strong>Adding practical elements:</strong></p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

mkdir -p output
echo "Script started"
</code></pre>
<ul>
<li>
<p><strong><code>mkdir -p output</code></strong> – Creates a directory called <code>output</code> if it doesn’t exist. The <code>-p</code> flag prevents errors if the directory is already there. This establishes a predictable place for your results.</p>
</li>
<li>
<p><strong><code>echo "Script started"</code></strong> – Prints a message to confirm the script is running. This is helpful for logging and debugging, especially when scripts run unattended.</p>
</li>
</ul>
<hr>
<h2 id="how-to-run-bash-scripts"><a class="header" href="#how-to-run-bash-scripts">How to Run Bash Scripts</a></h2>
<p>Now that you understand what goes inside a script, let’s learn <strong>how to actually run it</strong>.</p>
<h3 id="method-1-save-and-execute-recommended"><a class="header" href="#method-1-save-and-execute-recommended">Method 1: Save and Execute (Recommended)</a></h3>
<p><strong>Step 1: Create the script file</strong></p>
<pre><code class="language-bash"># Open a text editor (nano, vim, or any editor)
nano my_script.sh
</code></pre>
<p><strong>Step 2: Paste your script content</strong></p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

mkdir -p output
echo "Script started"
</code></pre>
<p><strong>Step 3: Save and exit</strong></p>
<ul>
<li>In <code>nano</code>: Press <code>Ctrl+O</code> (save), then <code>Ctrl+X</code> (exit)</li>
<li>In <code>vim</code>: Press <code>ESC</code>, type <code>:wq</code>, press <code>Enter</code></li>
</ul>
<p><strong>Step 4: Make the script executable</strong></p>
<pre><code class="language-bash">chmod +x my_script.sh
</code></pre>
<p><strong>What <code>chmod +x</code> does:</strong> This command gives the file “execute” permission, allowing you to run it as a program.</p>
<p><strong>Step 5: Run the script</strong></p>
<pre><code class="language-bash">./my_script.sh
</code></pre>
<p><strong>Why the <code>./</code> prefix?</strong> The <code>./</code> tells Bash to look for the script in the current directory.</p>
<hr>
<h3 id="method-2-using-bash-command-without-chmod"><a class="header" href="#method-2-using-bash-command-without-chmod">Method 2: Using <code>bash</code> Command (Without chmod)</a></h3>
<p>If you don’t want to make the file executable, you can still run it:</p>
<pre><code class="language-bash">bash my_script.sh
</code></pre>
<p>This works even without <code>chmod +x</code>, but the preferred method is still to use <code>chmod +x</code> and <code>./script.sh</code>.</p>
<hr>
<h2 id="the-big-picture-manual-vs-automated-analysis"><a class="header" href="#the-big-picture-manual-vs-automated-analysis">The Big Picture: Manual vs. Automated Analysis</a></h2>
<p>Imagine you have a classroom with 100 students and need to process each student’s assignment.</p>
<p><strong>Two approaches:</strong></p>
<ol>
<li>
<p><strong>Manual Approach:</strong></p>
<ul>
<li>Type the command for Student 1</li>
<li>Wait for it to finish</li>
<li>Type for Student 2</li>
<li>Wait again…</li>
<li>Repeat 98 more times (takes days, prone to typos)</li>
</ul>
</li>
<li>
<p><strong>Automated Approach:</strong></p>
<ul>
<li>Write a small instruction sheet (a script)</li>
<li>Give it to a “robot” (your computer)</li>
<li>The robot processes all 100 students while you drink coffee</li>
</ul>
</li>
</ol>
<p>This tutorial teaches you the automated approach for ChIP-seq data.</p>
<hr>
<h2 id="part-1-understanding-sample-lists"><a class="header" href="#part-1-understanding-sample-lists">Part 1: Understanding Sample Lists</a></h2>
<h3 id="the-roll-call-analogy"><a class="header" href="#the-roll-call-analogy">The “Roll Call” Analogy</a></h3>
<p>Imagine grading 100 students. You don’t want to type <code>"Student_John_Doe_Homework_Final_v2.docx"</code> every single time. You just want a simple list:</p>
<ul>
<li>John</li>
<li>Sarah</li>
<li>Mike</li>
</ul>
<p>In bioinformatics, we feel the same way about our sequencing files.</p>
<p><strong>The Problem:</strong></p>
<p>Our sequencing files have long, complex names like:</p>
<pre><code class="language-text">Control_A_H3K9ac_R1.fastq.gz
Control_B_H3K9ac_R1.fastq.gz
</code></pre>
<p><strong>The Goal:</strong></p>
<p>Create a clean list of sample IDs (like a “roll call”) that we can feed into automated scripts:</p>
<pre><code class="language-text">Control_A_H3K9ac
Control_B_H3K9ac

</code></pre>
<p><strong>Why do we need this?</strong></p>
<p>This simple text file will allow our computer to automatically loop through every sample and process them one by one. Instead of typing commands 100 times, we type it once and let the loop do the work.</p>
<hr>
<h2 id="part-2-creating-your-sample-list"><a class="header" href="#part-2-creating-your-sample-list">Part 2: Creating Your Sample List</a></h2>
<h3 id="step-1-verify-your-files"><a class="header" href="#step-1-verify-your-files">Step 1: Verify Your Files</a></h3>
<p>Before creating any list, always check what files you actually have.</p>
<pre><code class="language-bash">ls *.fastq.gz 
</code></pre>
<p><strong>What this does:</strong></p>
<ul>
<li><code>ls</code> = “list” command</li>
<li><code>*.fastq.gz</code> = show only files ending in <code>.fastq.gz</code></li>
</ul>
<p>This explicitly targets FASTQ files and is useful at the very start of any sequencing workflow (RNA-seq, ChIP-seq, ATAC-seq, CUT&amp;RUN) to quickly verify that your input files are named correctly and consistently.</p>
<hr>
<h3 id="step-2-extract-clean-sample-names"><a class="header" href="#step-2-extract-clean-sample-names">Step 2: Extract Clean Sample Names</a></h3>
<p>Now we need to remove the messy file extensions to get clean sample IDs. We’ll use a tool called <code>sed</code> (Stream Editor) for this.</p>
<hr>
<h4 id="scenario-a-single-end-reads"><a class="header" href="#scenario-a-single-end-reads">Scenario A: Single-End Reads</a></h4>
<p>If you have <strong>single-end sequencing data</strong> , use this approach:</p>
<h4 id="method-1-step-by-step"><a class="header" href="#method-1-step-by-step">Method 1: Step-by-step</a></h4>
<p>This method breaks down the process into individual steps so you can see what’s happening at each stage.</p>
<blockquote>
<p><strong>Note:</strong> In real workflows, your FASTQ files are typically stored in a subdirectory like <code>raw/</code> or <code>fastq_raw/</code>. It is better to create the sample list in the <code>raw/</code> folder and copy that list to working directory</p>
</blockquote>
<p><strong>Step 1: List all FASTQ files from the raw folder and save to a text file</strong></p>
<pre><code class="language-bash">cd raw/
ls *.fastq.gz &gt; samples.txt
</code></pre>
<p>This command finds all files ending in <code>.fastq.gz</code> inside the <code>raw/</code> folder and saves their names to <code>samples.txt</code>.</p>
<p><strong>Step 2: Check what got saved</strong></p>
<pre><code class="language-bash">cat samples.txt
</code></pre>
<p>This displays the contents of <code>samples.txt</code> so you can verify the filenames. You should see:</p>
<pre><code class="language-text">Control_A_H3K9ac.fastq.gz
Control_B_H3K9ac.fastq.gz
</code></pre>
<p><strong>Step 3: Remove the path and <code>.fastq.gz</code> extension from each line</strong></p>
<pre><code class="language-bash">sed 's/.fastq.gz//' samples.txt &gt; sample_id.txt
</code></pre>
<p><strong>What this does:</strong></p>
<ul>
<li>Second <code>sed 's/.fastq.gz//'</code> = Remove the <code>.fastq.gz</code> extension</li>
<li><code>&gt;</code> = Redirect the final output to a new file</li>
<li><code>sample_id.txt</code> = Save the cleaned names here</li>
</ul>
<p><strong>Step 4: Verify the final result</strong></p>
<pre><code class="language-bash">cat sample_id.txt
</code></pre>
<p>Now you should see clean sample IDs without paths or extensions:</p>
<pre><code class="language-text">Control_A_H3K9ac
Control_B_H3K9ac
</code></pre>
<hr>
<h4 id="method-2-one-line-command-recommended"><a class="header" href="#method-2-one-line-command-recommended">Method 2: One-line command (recommended)</a></h4>
<p>Once you understand the steps above, you can combine them into one efficient command:</p>
<pre><code class="language-bash">ls *.fastq.gz |  sed 's/.fastq.gz//' &gt; sample_id.txt
</code></pre>
<p><strong>What the pipe (<code>|</code>) does:</strong></p>
<p>Instead of saving to intermediate files, the pipe passes output directly from one command to the next:</p>
<ol>
<li><code>ls *.fastq.gz</code> lists the files</li>
<li><code>sed</code> removes the <code>.fastq.gz</code> extension</li>
<li>Final result is saved to <code>sample_id.txt</code></li>
</ol>
<p>This is faster and cleaner than the step-by-step method.  Then moving the sample_id.txt to working directory.</p>
<pre><code>cd ..
mv raw/sample_id.txt .

</code></pre>
<hr>
<h4 id="scenario-b-paired-end-reads-most-common"><a class="header" href="#scenario-b-paired-end-reads-most-common">Scenario B: Paired-End Reads (Most Common)</a></h4>
<p>Most ChIP-seq experiments use <strong>paired-end sequencing</strong>, which produces <em>two</em> files per sample:</p>
<pre><code class="language-text">Control_A_H3K9ac_R1.fastq.gz
Control_A_H3K9ac_R2.fastq.gz
Control_B_H3K9ac_R1.fastq.gz
Control_B_H3K9ac_R2.fastq.gz
</code></pre>
<p><strong>The challenge:</strong> We don’t want <code>Control_A_H3K9ac</code> to appear twice in our list. We only want each sample name <em>once</em>.</p>
<p><strong>The solution:</strong> Target only the <code>_R1</code> files.</p>
<pre><code class="language-bash">ls *_R1.fastq.gz | sed 's/_R1.fastq.gz//' &gt; sample_id.txt
</code></pre>
<p><strong>Why look for R1?</strong></p>
<p>By listing only the <code>_R1</code> files, we get exactly one entry per sample. We then strip off the <code>_R1.fastq.gz</code> suffix to get the clean sample name.</p>
<p>The script will automatically know to look for both <code>_R1</code> and <code>_R2</code> files later when we use this list.</p>
<hr>
<h3 id="why-not-create-the-list-manually"><a class="header" href="#why-not-create-the-list-manually">Why Not Create the List Manually?</a></h3>
<p>You <em>could</em> just type sample names into a text file yourself. However:</p>
<ul>
<li><strong>Prone to typos:</strong> One wrong character breaks your analysis</li>
<li><strong>Not verifiable:</strong> Using <code>ls</code> ensures you only list files that actually exist</li>
</ul>
<p>Automation prevents these errors.</p>
<hr>
<h2 id="part-3-using-your-sample-list-in-automation"><a class="header" href="#part-3-using-your-sample-list-in-automation">Part 3: Using Your Sample List in Automation</a></h2>
<p>Now that we have <code>sample_id.txt</code>, we can use it to automate processing of all samples.</p>
<h3 id="understanding-the-concept"><a class="header" href="#understanding-the-concept">Understanding the Concept</a></h3>
<p>Since we know the sample ID (e.g., <code>Control_A_H3K9ac</code>), we can tell our script:</p>
<blockquote>
<p>“For each sample ID, look for two files: the sample name plus <code>_R1.fastq.gz</code> and the sample name plus <code>_R2.fastq.gz</code>”</p>
</blockquote>
<p>The computer can construct these filenames automatically.</p>
<hr>
<h3 id="example-1-basic-loop-to-verify-file-pairs"><a class="header" href="#example-1-basic-loop-to-verify-file-pairs">Example 1: Basic Loop to Verify File Pairs</a></h3>
<p>This script reads your sample list and prints out the paired filenames:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

while read -r sample; do
  echo "sample_id: $sample"

  fq1="${sample}_R1.fastq.gz"
  fq2="${sample}_R2.fastq.gz"

  echo "paired end: $fq1 : $fq2"
done &lt; sample_id.txt
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">sample_id: Control_A_H3K9ac
paired end:  Control_A_H3K9ac_R1.fastq.gz  :  Control_A_H3K9ac_R2.fastq.gz

sample_id: Control_B_H3K9ac
paired end:    Control_B_H3K9ac_R1.fastq.gz  :  Control_B_H3K9ac_R2.fastq.gz
</code></pre>
<p><strong>What this script does:</strong></p>
<ul>
<li><code>while read -r sample</code> – Reads one line (sample ID) at a time from <code>sample_id.txt</code></li>
<li><code>fq1="${sample}_R1.fastq.gz"</code> – Constructs the forward read filename</li>
<li><code>fq2="${sample}_R2.fastq.gz"</code> – Constructs the reverse read filename</li>
<li><code>echo</code> – Prints the results so you can verify</li>
</ul>
<hr>
<h3 id="example-2-adding-directory-paths"><a class="header" href="#example-2-adding-directory-paths">Example 2: Adding Directory Paths</a></h3>
<p>In real workflows, your raw FASTQ files are usually in a specific folder. Let’s account for that:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

RAW_DIR="fastq_raw"

while read -r sample; do
  echo "sample_id: $sample"

  fq1="${RAW_DIR}/${sample}_R1.fastq.gz"
  fq2="${RAW_DIR}/${sample}_R2.fastq.gz"

  echo "inputs:"
  echo "  $fq1"
  echo "  $fq2"

done &lt; sample_id.txt
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">sample_id: Control_A_H3K9ac
inputs:
  fastq_raw/Control_A_H3K9ac_R1.fastq.gz
  fastq_raw/Control_A_H3K9ac_R2.fastq.gz

sample_id: Control_B_H3K9ac
inputs:
  fastq_raw/Control_B_H3K9ac_R1.fastq.gz
  fastq_raw/Control_B_H3K9ac_R2.fastq.gz
</code></pre>
<p><strong>Key change:</strong></p>
<ul>
<li><code>RAW_DIR="fastq_raw"</code> – Defines where your input files are located</li>
<li><code>${RAW_DIR}/${sample}_R1.fastq.gz</code> – Constructs the full path to each file</li>
</ul>
<hr>
<h3 id="example-3-complete-workflow-with-input-and-output-directories"><a class="header" href="#example-3-complete-workflow-with-input-and-output-directories">Example 3: Complete Workflow with Input and Output Directories</a></h3>
<p>This example shows a real bioinformatics workflow pattern: reading files from an <strong>input directory</strong> and writing results to an <strong>output directory</strong>.</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

RAW_DIR="fastq_raw"
OUT_DIR="bowtie_align"

mkdir -p "$OUT_DIR"

while read -r sample; do
  echo "sample_id: $sample"

  fq1="${RAW_DIR}/${sample}_R1.fastq.gz"
  fq2="${RAW_DIR}/${sample}_R2.fastq.gz"
  bam="${OUT_DIR}/${sample}.sorted.bam"

  echo "inputs:"
  echo "  $fq1"
  echo "  $fq2"

  echo "output:"
  echo "  $bam"

  echo "bowtie2 command: bowtie2 -x hg38_index -1 $fq1 -2 $fq2 | samtools sort -o $bam"
  echo
done &lt; sample_id.txt
</code></pre>
<p><strong>Understanding the directory structure:</strong></p>
<p>This script follows a crucial bioinformatics principle: <strong>separate input data from output results</strong>.</p>
<ul>
<li><strong>Input directory</strong> (<code>RAW_DIR="fastq_raw"</code>): Where your raw sequencing files are stored. This should be read-only to preserve original data.</li>
<li><strong>Output directory</strong> (<code>OUT_DIR="bowtie_align"</code>): Where processed results will be saved. Created automatically if it doesn’t exist.</li>
</ul>
<p><strong>Breaking down the script:</strong></p>
<ol>
<li>
<p><strong><code>mkdir -p "$OUT_DIR"</code></strong> – Creates the output directory before processing starts. The <code>-p</code> flag means “don’t error if it already exists.”</p>
</li>
<li>
<p><strong>Input file construction:</strong></p>
<ul>
<li><code>fq1="${RAW_DIR}/${sample}_R1.fastq.gz"</code> – Forward reads from the raw data folder</li>
<li><code>fq2="${RAW_DIR}/${sample}_R2.fastq.gz"</code> – Reverse reads from the raw data folder</li>
</ul>
</li>
<li>
<p><strong>Output file construction:</strong></p>
<ul>
<li><code>bam="${OUT_DIR}/${sample}.sorted.bam"</code> – Aligned, sorted BAM file will go in the output folder</li>
</ul>
</li>
<li>
<p><strong>The command preview:</strong></p>
<ul>
<li>Shows what the actual bowtie2 alignment command would be</li>
<li><code>bowtie2 -x hg38_index</code> – Uses the human genome reference</li>
<li><code>-1 $fq1 -2 $fq2</code> – Paired-end input files</li>
<li><code>| samtools sort -o $bam</code> – Pipes output to samtools to create sorted BAM</li>
</ul>
</li>
</ol>
<p><strong>Output:</strong></p>
<pre><code class="language-text">sample_id: Control_A_H3K9ac
inputs:
  fastq_raw/Control_A_H3K9ac_R1.fastq.gz
  fastq_raw/Control_A_H3K9ac_R2.fastq.gz
output:
  bowtie_align/Control_A_H3K9ac.sorted.bam
bowtie2 command: bowtie2 -x hg38_index -1 fastq_raw/Control_A_H3K9ac_R1.fastq.gz -2 fastq_raw/Control_A_H3K9ac_R2.fastq.gz | samtools sort -o bowtie_align/Control_A_H3K9ac.sorted.bam

sample_id: Control_B_H3K9ac
inputs:
  fastq_raw/Control_B_H3K9ac_R1.fastq.gz
  fastq_raw/Control_B_H3K9ac_R2.fastq.gz
output:
  bowtie_align/Control_B_H3K9ac.sorted.bam
bowtie2 command: bowtie2 -x hg38_index -1 fastq_raw/Control_B_H3K9ac_R1.fastq.gz -2 fastq_raw/Control_B_H3K9ac_R2.fastq.gz | samtools sort -o bowtie_align/Control_B_H3K9ac.sorted.bam
</code></pre>
<p><strong>Why organize this way?</strong></p>
<p>This directory structure keeps your project clean and organized:</p>
<pre><code class="language-text">your_project/
├── fastq_raw/              ← Original data (never modified)
│   ├── Control_A_H3K9ac_R1.fastq.gz
│   ├── Control_A_H3K9ac_R2.fastq.gz
│   └── ...
├── bowtie_align/           ← Alignment results (can regenerate)
│   ├── Control_A_H3K9ac.sorted.bam
│   └── ...
├── sample_id.txt           ← Sample list
└── analysis_script.sh      ← This script
</code></pre>
<p>If something goes wrong with alignment, you can safely delete the <code>bowtie_align/</code> folder and rerun the script without touching your original raw data.</p>
<hr>
<p><strong>Best Practice: Separate Folders for Each Process</strong></p>
<p>In real ChIP-seq analysis, you should create a <strong>separate output folder for each processing step and file type</strong>. This keeps your project organized and makes troubleshooting easier. A typical ChIP-seq project might have folders like:</p>
<ul>
<li><code>fastq_raw/</code> - Original FASTQ files from sequencing</li>
<li><code>fastqc_reports/</code> - Quality control reports</li>
<li><code>trimmed_fastq/</code> - Adapter-trimmed reads (if needed)</li>
<li><code>bowtie_align/</code> - Aligned BAM files</li>
<li><code>dedup_bam/</code> - Deduplicated BAM files</li>
<li><code>peaks/</code> - Peak calling results from MACS2</li>
<li><code>bigwig/</code> - Coverage tracks for genome browsers</li>
<li><code>qc_metrics/</code> - deepTools quality metrics</li>
</ul>
<p>This folder structure makes it easy to: (1) track which processing stage created which files, (2) quickly find the data you need, (3) delete and regenerate intermediate files without affecting earlier steps, and (4) share your work with collaborators who can immediately understand your project organization.</p>
<hr>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p><strong>What you learned:</strong></p>
<ol>
<li><strong>Safe scripting:</strong> Start every script with <code>#!/bin/bash</code> and <code>set -euo pipefail</code></li>
<li><strong>Sample list creation:</strong> Use <code>ls</code> and <code>sed</code> to extract clean sample IDs from messy filenames</li>
<li><strong>Single-end:</strong> <code>ls *.fastq.gz | sed 's/.fastq.gz//' &gt; sample_id.txt</code></li>
<li><strong>Paired-end:</strong> <code>ls *_R1.fastq.gz | sed 's/_R1.fastq.gz//' &gt; sample_id.txt</code></li>
<li><strong>Automation:</strong> Use <code>while read</code> loops to process all samples automatically</li>
</ol>
<p><strong>The key insight:</strong>
This simple text file (<code>sample_id.txt</code>) acts as a “roll call” or “attendance sheet” for your entire analysis pipeline. It’s the foundation that makes large-scale automation possible.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> Now that you understand Bash automation, we’ll use these skills to download real ChIP-seq data from public databases.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="getting-the-raw-data-fastq"><a class="header" href="#getting-the-raw-data-fastq">Getting the Raw Data (FASTQ)</a></h1>
<p><code>GEO</code> <code>SRA</code> <code>FASTQ</code> <code>fasterq-dump</code> <code>sra-toolkit</code> <code>data-download</code> <code>sequencing-data</code> <code>NCBI</code> <code>public-datasets</code></p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Reminder:</strong> While this tutorial teaches you how to download data from SRA, our focus is on <a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE115704">SRA data</a>.</p>
</blockquote>
<h2 id="level-1-basic-concept"><a class="header" href="#level-1-basic-concept">Level 1: Basic Concept</a></h2>
<h3 id="the-library-analogy"><a class="header" href="#the-library-analogy">The “Library” Analogy</a></h3>
<p>Before we download anything, it helps to understand where the data lives. Think of the public databases like a University Library.</p>
<ul>
<li><strong>GEO (Gene Expression Omnibus):</strong> This is the <strong>Card Catalog</strong>. It has the descriptions (Metadata) of the experiments—like “H3K27ac in Breast Cancer”—but it usually doesn’t hold the actual heavy books (data files).</li>
<li><strong>SRA (Sequence Read Archive) &amp; ENA (European Nucleotide Archive):</strong> These are the <strong>Stacks</strong>. This is where the actual raw data files are stored.</li>
</ul>
<p><strong>Your Goal:</strong> You find an interesting study in the Catalog (GEO), get its ID, and then send a runner (our software tool) to the Stacks (SRA/ENA) to fetch the files.</p>
<h3 id="the-files-you-will-encounter"><a class="header" href="#the-files-you-will-encounter">The Files You Will Encounter</a></h3>
<p>As we process data, we change formats. Think of it like this:</p>
<ol>
<li><strong>FASTQ (Raw Reads):</strong> The jumbled words. This is what comes off the sequencer. It’s just millions of short strings of letters (A, C, G, T) with no context.</li>
<li><strong>BAM (Aligned Reads):</strong> The assembled sentences. We map the words to a reference genome so we know where they belong.</li>
<li><strong>BED/BigWig (Signals):</strong> The highlighted passages. These are simplified files that show us where the interesting “peaks” (protein binding sites) are.</li>
</ol>
<hr>
<h2 id="level-2-fetching-the-data"><a class="header" href="#level-2-fetching-the-data">Level 2: Fetching the data</a></h2>
<p>Complete information for all sequencing runs associated with this repository is available through the <a href="https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA475794&amp;o=acc_s%3Aa">NCBI SRA Run Selector (PRJNA475794)</a>. The Run Selector provides an interactive interface to inspect sequencing metadata, including library layout, platform, read length, and experimental design.</p>
<p>From this interface, you can download the full metadata table as well as a plain accession list containing the SRR identifiers. The accession list can be saved as <code>srr_list.txt</code> and used directly for automated data retrieval. Unwanted runs can be removed from this file before download, allowing precise control over which datasets are processed.</p>
<p>To download data, we use a tool called <a href="https://github.com/rpetit3/fastq-dl">fastq-dl</a>. It acts like a smart librarian—you just give it the ID number, and it deals with the complicated databases for you.</p>
<h3 id="21-download-a-single-sample"><a class="header" href="#21-download-a-single-sample">2.1 Download a Single Sample</a></h3>
<p>If you have a Run ID (starts with <strong>SRR</strong> or <strong>ERR</strong>), use this command:</p>
<pre><code class="language-bash"># Download H3K27me3 IP replicate 1
fastq-dl --accession SRR7297996 --provider SRA --cpus 4

# Or from ENA (often faster/more reliable)
fastq-dl --accession SRR7297996 --provider ena
</code></pre>
<h3 id="22-download-multiple-samples-the-loop"><a class="header" href="#22-download-multiple-samples-the-loop">2.2 Download Multiple Samples (The Loop)</a></h3>
<p>Usually, you need to download many samples. Instead of typing the command 10 times, we put the IDs in a list.</p>
<ol>
<li>
<p>Create a file named <code>srr_list.txt</code> with one ID per line:</p>
<pre><code class="language-text">SRR7297996
SRR7297997
SRR7298011
SRR7298012
</code></pre>
</li>
<li>
<p>Run this “Loop” to download them one by one:</p>
</li>
</ol>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

RAW_DIR="fastq_raw"
mkdir -p "$RAW_DIR"

while read -r acc; do
  echo "Downloading accession: $acc"

  fastq-dl \
    --accession "$acc" \
    --provider SRA \
    --cpus 1 \
    --outdir "$RAW_DIR"

  echo "Finished downloading: $acc"
done &lt; srr_list.txt

</code></pre>
<p><strong>Directory structure after download:</strong></p>
<pre><code class="language-text">chipseq_tutorial/
├── fastq_raw/                    ← Downloaded files from SRA/ENA
│   ├── SRR7297996.fastq.gz
│   ├── SRR7297997.fastq.gz
│   ├── SRR7298011.fastq.gz
│   ├── SRR7298012.fastq.gz
│   └── ...
└── srr_list.txt                  ← SRR ID list used for download

</code></pre>
<h3 id="23-renaming-downloaded-files"><a class="header" href="#23-renaming-downloaded-files">2.3: Renaming Downloaded Files</a></h3>
<p>After downloading, the files will have generic SRR IDs as names. It’s best practice to rename them to biological sample names based on the metadata:</p>
<p><strong>Sample Mapping Table:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>SRR ID</th><th>Sample Type</th><th>Descriptive Name</th></tr>
</thead>
<tbody>
<tr><td>SRR7297996</td><td>H3K27me3 IP</td><td>H3K27me3_IP_rep1</td></tr>
<tr><td>SRR7297997</td><td>H3K27me3 IP</td><td>H3K27me3_IP_rep2</td></tr>
<tr><td>SRR7298011</td><td>Input control</td><td>Input_rep1</td></tr>
<tr><td>SRR7298012</td><td>Input control</td><td>Input_rep2</td></tr>
</tbody>
</table>
</div>
<p><strong>Renaming Script:</strong></p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

cd fastq_raw/

# Rename SRR7297996 (H3K27me3 IP rep1)
mv SRR7297996.fastq.gz H3K27me3_IP_rep1.fastq.gz

# Rename SRR7297997 (H3K27me3 IP rep2)
mv SRR7297997.fastq.gz H3K27me3_IP_rep2.fastq.gz

# Rename SRR7298011 (Input rep1)
mv SRR7298011.fastq.gz Input_rep1.fastq.gz

# Rename SRR7298012 (Input rep2)
mv SRR7298012.fastq.gz Input_rep2.fastq.gz

echo "Renaming complete!"
</code></pre>
<h3 id="24-creating-sample-id-list"><a class="header" href="#24-creating-sample-id-list">2.4: Creating Sample ID List</a></h3>
<p>After renaming, create <code>sample_id.txt</code> with clean sample names for downstream automation:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

# Create sample_id.txt from renamed files
cd fastq_raw/
ls *.fastq.gz | sed 's/.fastq.gz//' &gt; ../sample_id.txt

cd ..
mv fastq_raw/sample_id.txt .
cat sample_id.txt

</code></pre>
<p><strong>Contents of <code>sample_id.txt</code>:</strong></p>
<pre><code class="language-text">H3K27me3_IP_rep1
H3K27me3_IP_rep2
Input_rep1
Input_rep2
</code></pre>
<p>This file will be used in all downstream automation loops (QC, alignment, deduplication, etc.).</p>
<p><strong>Directory structure after renaming:</strong></p>
<pre><code class="language-text">chipseq_tutorial/
├── fastq_raw/                    ← Renamed for clarity
│   └── ...
├── srr_list.txt                  ← Original SRR ID list
└── sample_id.txt                 ← Clean sample names for automation

</code></pre>
<h3 id="23-parallel-download-the-fast-way"><a class="header" href="#23-parallel-download-the-fast-way">2.3 Parallel Download (The Fast Way)</a></h3>
<p>If you have a powerful computer, you can download multiple files at the same time using <code>parallel</code>.</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

mkdir -p fastq_raw

parallel -j 4 \
  'fastq-dl --accession {} --provider SRA --cpus 1 --outdir fastq_raw' \
  :::: srr_list.txt

</code></pre>
<p><strong>Adding echo statements for progress tracking:</strong></p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

mkdir -p fastq_raw

parallel -j 4 \
  'echo "Starting download: {}" &amp;&amp;
   fastq-dl --accession {} --provider SRA --cpus 1 --outdir fastq_raw &amp;&amp;
   echo "Finished download: {}"' \
  :::: srr_list.txt
</code></pre>
<h3 id="24-download-an-entire-study"><a class="header" href="#24-download-an-entire-study">2.4 Download an Entire Study</a></h3>
<p>You can also download everything associated with a study ID (starts with <strong>SRP</strong> or <strong>PRJNA</strong>):</p>
<pre><code class="language-bash">fastq-dl --accession SRP115709
</code></pre>
<p><em>Note: Be careful! A whole study might have hundreds of files.</em></p>
<hr>
<h3 id="connecting-geo-to-sra"><a class="header" href="#connecting-geo-to-sra">Connecting GEO to SRA</a></h3>
<p>How do we find the <strong>SRR</strong> numbers?
In GEO, you will see a hierarchy. It’s important not to mix these up:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Level</th><th style="text-align: left">Prefix (SRA / ENA)</th><th style="text-align: left">What It Is</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><strong>Project</strong></td><td style="text-align: left">PRJNA / PRJEB</td><td style="text-align: left">The umbrella project (e.g., “Breast Cancer Epigenomics 2024”).</td></tr>
<tr><td style="text-align: left"><strong>Study</strong></td><td style="text-align: left">SRP / ERP</td><td style="text-align: left">A specific paper or dataset.</td></tr>
<tr><td style="text-align: left"><strong>Sample</strong></td><td style="text-align: left">SRS / ERS</td><td style="text-align: left">The biological sample (e.g., “Patient 5 Tumor”).</td></tr>
<tr><td style="text-align: left"><strong>Experiment</strong></td><td style="text-align: left">SRX / ERX</td><td style="text-align: left">The library prep info.</td></tr>
<tr><td style="text-align: left"><strong>Run</strong></td><td style="text-align: left"><strong>SRR / ERR</strong></td><td style="text-align: left"><strong>The actual data.</strong> This is what you download.</td></tr>
</tbody>
</table>
</div>
<h3 id="technical-replicates-multi-lane"><a class="header" href="#technical-replicates-multi-lane">Technical Replicates (Multi-lane)</a></h3>
<p>Sometimes, one biological sample is sequenced across multiple “lanes” of a machine to get more reads.</p>
<ul>
<li><strong>Result:</strong> You might see <code>SRR900100</code> and <code>SRR900101</code> for the <em>same</em> sample.</li>
<li><strong>Action:</strong> <code>fastq-dl</code> will download them. Later, we will merge these FASTQ files together so we have one big file for that sample.</li>
</ul>
<hr>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<ol>
<li><strong>Understand:</strong> GEO is for metadata; SRA/ENA is for data.</li>
<li><strong>Identify:</strong> Find the <strong>SRR</strong> (Run) IDs for your samples.</li>
<li><strong>Download:</strong> Use <code>fastq-dl</code> with a loop or parallel command to fetch the FASTQ files.</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> The FASTQ files are now available. We proceed with read inspection, quality control, and trimming.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="understanding-and-cleaning-your-data-fastq--fastp"><a class="header" href="#understanding-and-cleaning-your-data-fastq--fastp">Understanding and Cleaning Your Data (FASTQ &amp; fastp)</a></h1>
<p><code>FASTQ-format</code> <code>fastp</code> <code>quality-control</code> <code>adapter-trimming</code> <code>Phred-scores</code> <code>read-filtering</code> <code>QC-reports</code> <code>quality-assessment</code></p>
<h2 id="1-basic-concept-the-anatomy-of-a-read"><a class="header" href="#1-basic-concept-the-anatomy-of-a-read">1: Basic Concept (The Anatomy of a Read)</a></h2>
<p>A FASTQ file is just a text file full of DNA sequences. But unlike a simple list of letters, every single read carries extra baggage (its quality score).</p>
<p>Think of every read like a <strong>Luggage Tag</strong> with 4 lines of information:</p>
<ol>
<li><strong>Line 1 (The Header):</strong> Starts with <code>@</code>. This is the <strong>ID Card</strong>. It tells you the machine name, flowcell lane, and coordinates.</li>
<li><strong>Line 2 (The Sequence):</strong> The DNA letters (<code>ACTG...</code>). This is the <strong>Content</strong> inside the bag.</li>
<li><strong>Line 3 (The Spacer):</strong> Starts with <code>+</code>. Just a divider.</li>
<li><strong>Line 4 (The Quality):</strong> A string of weird characters (<code>F:F#,,...</code>). This is the <strong>Trust Score</strong>. Each character represents the probability that the corresponding base in Line 2 is wrong.</li>
</ol>
<p><strong>Example Read:</strong></p>
<pre><code class="language-text">@SN227:495:CA0TUACXX:1:1106:1159:2114 1:N:0:ATCACG  &lt;-- ID: Read #1
GTAAAAAGATTACATATATATTTAAAGTACACTGTAATTCTTANCA    &lt;-- DNA: "N" means the machine failed to call that base
+                                                  &lt;-- Spacer
FDFFFHHHHHJIJGIJIJJHJJJJJJIIJIJGIHFIIJJIIIIJG        &lt;-- Quality: Each character encodes a Phred quality score (Illumina 1.8+, ASCII offset 33).

</code></pre>
<hr>
<h2 id="level-2-execution-the-car-wash"><a class="header" href="#level-2-execution-the-car-wash">Level 2: Execution (The Car Wash)</a></h2>
<p>Before we start analyzing, we need to clean our data.</p>
<ul>
<li><strong>The Problem:</strong> Sequencers sometimes make mistakes, especially at the ends of reads. They also leave “adapters” (artificial tags) attached to the DNA.</li>
<li><strong>The Solution:</strong> We use a tool called <strong>fastp</strong>. It acts like an automatic car wash: dirty reads go in, clean reads come out.</li>
</ul>
<h3 id="21-basic-cleaning-single-end"><a class="header" href="#21-basic-cleaning-single-end">2.1 Basic Cleaning (Single-End)</a></h3>
<pre><code class="language-bash"># -i: Input (dirty)
# -o: Output (clean)
fastp -i fastq_raw/H3K27me3_IP_rep1.fastq.gz -o fastq_cleaned/H3K27me3_IP_rep1.clean.fastq.gz
</code></pre>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>This dataset uses single-end sequencing.</strong> If you have paired-end data, you would use:</p>
<pre><code class="language-bash">fastp -i in.R1.fq.gz -I in.R2.fq.gz -o out.R1.fq.gz -O out.R2.fq.gz
</code></pre>
</blockquote>
<p><strong>What does fastp do automatically?</strong></p>
<ul>
<li><strong>Quality Filtering:</strong> Drops reads if too many bases have low scores (default: Phred -q &lt; 15).</li>
<li><strong>Length Filtering:</strong> Drops reads that become too short after trimming (default: -l &lt; 15bp).</li>
<li><strong>Adapter Removal:</strong> Finds and cuts off adapter sequences automatically.</li>
</ul>
<hr>
<h2 id="level-3-advanced-analysis-the-math"><a class="header" href="#level-3-advanced-analysis-the-math">Level 3: Advanced Analysis (The Math)</a></h2>
<h3 id="31-quick-stats-with-awk"><a class="header" href="#31-quick-stats-with-awk">3.1 Quick Stats with AWK</a></h3>
<p>Sometimes you don’t want to run a full report; you just want to know “How many reads do I have?”
You can use <code>awk</code> (a math tool for text) to count directly from the compressed file.</p>
<p><strong>Count Total Reads:</strong></p>
<pre><code class="language-bash"># A FASTQ record is 4 lines. We count total lines and divide by 4.
gzcat fastq_raw/H3K27me3_IP_rep1.fastq.gz | wc -l | awk '{print $1/4 " reads"}'
</code></pre>
<p><strong>Count Total Bases (Coverage):</strong></p>
<pre><code class="language-bash"># Sums the length of line 2 (sequence) for every record
gzcat fastq_raw/H3K27me3_IP_rep1.fastq.gz | awk 'NR%4==2 {b+=length($0)} END{print b " bases"}'
</code></pre>
<ul>
<li><em>Approximation:</em> If you have 100 Million bases and your genome is 3 Billion bases (Human), your coverage is roughly 0.03x.</li>
</ul>
<h3 id="32-batch-processing"><a class="header" href="#32-batch-processing">3.2 Batch Processing</a></h3>
<p>If you have 50 files, you can use a script to run <code>fastp</code> on all of them in parallel.
The <code>fastp</code> developers provide a handy script called  <a href="https://github.com/OpenGene/fastp/blob/master/parallel.py">parallel.py</a>:</p>
<pre><code class="language-bash"># Process 3 files at a time (-f 3), using 2 threads per file (-t 2)
python parallel.py -i /fastq_raw -o /fastq_cleaned -r /fastp_reports -f 3 -t 2
</code></pre>
<p><strong>Parameter explanation:</strong></p>
<ul>
<li><code>-f 3</code>: Sets the batch size—the script processes 3 files at a time</li>
<li><code>-t 2</code>: Sets the number of threads per file—each file is processed with 2 threads</li>
</ul>
<p>This automatically finds pairs and generates HTML reports for every sample.</p>
<hr>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p><a href="https://github.com/OpenGene/fastp/blob/master/parallel.py">parallel.py</a> avoids the need to explicitly loop over <code>sample_id.txt</code> in a Bash script.</p>
</blockquote>
<pre><code class="language-text">chipseq_tutorial/
│   ├── Input_rep1.html
│   ├── Input_rep2.html
│   └── ...
└── sample_id.txt
</code></pre>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<ol>
<li><strong>Understand:</strong> FASTQ files have 4 lines per read; line 4 is the quality score.</li>
<li><strong>Action:</strong> Always run <code>fastp</code> to trim adapters, low-quality bases, and too-short reads.</li>
<li><strong>Check:</strong> Use <code>wc -l</code> or <code>awk</code> for instant feedback on your data size.</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> With clean reads in hand, we’re ready to align them to a reference genome using Bowtie2.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="alignment-solving-the-jigsaw-puzzle"><a class="header" href="#alignment-solving-the-jigsaw-puzzle">Alignment (Solving the Jigsaw Puzzle)</a></h1>
<p><code>Bowtie2</code> <code>alignment</code> <code>BAM-files</code> <code>single-end</code> <code>paired-end</code> <code>samtools</code> <code>genome-index</code> <code>MAPQ</code> <code>quality-control</code> <code>multimapping</code> <code>ChIP-seq</code> <code>flagstat</code> <code>MultiQC</code> <code>filtering</code></p>
<h2 id="basic-concept-the-puzzle"><a class="header" href="#basic-concept-the-puzzle">Basic Concept (The “Puzzle”)</a></h2>
<p>Imagine your Reference Genome is the <strong>Picture on the Puzzle Box</strong> (a complete image of the DNA).
Your Reads (FASTAS) are the millions of tiny <strong>Puzzle Pieces</strong> scattered on the floor.</p>
<p><strong>Alignment</strong> is simply picking up every piece and finding exactly where it fits on the picture.</p>
<ul>
<li><strong>The Input:</strong> Millions of jumbled reads.</li>
<li><strong>The Tool:</strong> <strong>Bowtie2</strong> (The Puzzle Solver).</li>
<li><strong>The Output:</strong> A <strong>BAM File</strong>. This is the digital record of where every piece belongs.</li>
</ul>
<hr>
<h2 id="execution-solving-it"><a class="header" href="#execution-solving-it">Execution (Solving It)</a></h2>
<h3 id="step-1-the-index-building-the-map"><a class="header" href="#step-1-the-index-building-the-map">Step 1: The Index (Building the Map)</a></h3>
<p>Before Bowtie2 can work, it needs to process the reference genome into a format it can search quickly. This is called an <strong>Index</strong>.</p>
<pre><code class="language-bash"># Example syntax: bowtie2-build [genome.fa] [prefix_name]
bowtie2-build genome_index/ce.fa genome_index/ce_index            # ce.fa = C. elegans reference genome
</code></pre>
<p><em>You only do this once!</em></p>
<p>You can download the C. elegans reference genome from Ensembl using the following link:  <a href="https://ftp.ensembl.org/pub/release-115/fasta/caenorhabditis_elegans/dna/Caenorhabditis_elegans.WBcel235.dna.toplevel.fa.gz">C. elegans genome</a>.  Place it in the <strong>genome_index</strong> directory, decompress it, and rename the file to <code>ce.fa</code></p>
<h3 id="after-indexing-bowtie2"><a class="header" href="#after-indexing-bowtie2">After Indexing (Bowtie2)</a></h3>
<pre><code class="language-text">chipseq_tutorial/
├── fastq_raw/
│   └── ...
├── fastq_cleaned/                ← Fastp cleaned reads
│   └── ...
├── fastp_reports/
│   └── ...
├── genome_index/           ← Bowtie2 index files
│   ├── ce_index.1.bt2
│   ├── ce_index.2.bt2
│   ├── ce_index.3.bt2
│   ├── ce_index.4.bt2
│   ├── ce_index.rev.1.bt2
│   └── ce_index.rev.2.bt2
└── sample_id.txt
</code></pre>
<h3 id="step-2-single-sample-alignment"><a class="header" href="#step-2-single-sample-alignment">Step 2: Single Sample Alignment</a></h3>
<p>We use a “Pipe” (<code>|</code>) to connect two tools: <code>bowtie2</code> aligns the data, and <code>samtools</code> sorts it immediately.</p>
<p><strong>Why Sort?</strong> A puzzle is useless if the pieces are in random order. We sort them by chromosome location (Left to Right) so we can look at them later.</p>
<p><strong>Run Bowtie2 alignment for a single-end sample</strong></p>
<p><strong>Input files needed:</strong></p>
<ul>
<li>Reference genome index: <code>genome_index/ce_index</code> (created in previous step)</li>
<li>Cleaned FASTQ file: <code>fastq_cleaned/H3K27me3_IP_rep1.clean.fastq.gz</code></li>
</ul>
<pre><code class="language-bash">mkdir -p bowalign

bowtie2 -x genome_index/ce_index \
  -U fastq_cleaned/H3K27me3_IP_rep1.clean.fastq.gz \
  -p 6 --no-unal \
  2&gt; bowalign/H3K27me3_IP_rep1.log | \
  samtools sort -@ 6 -o bowalign/H3K27me3_IP_rep1.sorted.bam

samtools index bowalign/H3K27me3_IP_rep1.sorted.bam
</code></pre>
<p><strong>What this does:</strong></p>
<ol>
<li><strong>bowtie2</strong> aligns reads to the reference genome using the <code>-U</code> flag for single-end data</li>
<li><strong>-p 6</strong> uses 6 CPU threads for faster processing</li>
<li><strong>–no-unal</strong> suppresses unaligned reads from output (reads that don’t match the genome are excluded, saving disk space and processing time downstream)</li>
<li><strong>2&gt;</strong> saves alignment statistics to a log file</li>
<li><strong>samtools sort</strong> sorts alignments by genomic position (required for downstream analysis)</li>
<li><strong>samtools index</strong> creates an index file (.bai) for fast random access</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>If you have paired-end data</strong>, use <code>-1</code> and <code>-2</code> flags instead of <code>-U</code>:</p>
</blockquote>
<pre><code class="language-bash">bowtie2 -x genome_index/ce_index \
  -1 fastq_cleaned/Sample_R1.clean.fastq.gz \
  -2 fastq_cleaned/Sample_R2.clean.fastq.gz \
  -p 6 --no-unal \
  2&gt; bowalign/Sample.log | samtools sort -@ 6 -o bowalign/Sample.sorted.bam

samtools index bowalign/Sample.sorted.bam
</code></pre>
<p><strong>Final Touch:</strong>
We always “index” the BAM file. Think of this as creating a <strong>Table of Contents</strong> so the computer can jump to any chromosome instantly.</p>
<pre><code class="language-bash">samtools index bowalign/H3K27me3_IP_rep1.sorted.bam
</code></pre>
<h3 id="output-structure"><a class="header" href="#output-structure"><strong>Output Structure</strong></a></h3>
<p>After running this step, your directory should look like:</p>
<pre><code class="language-text">bowalign/
├── H3K27me3_IP_rep1.log
├── H3K27me3_IP_rep1.sorted.bam
└── H3K27me3_IP_rep1.sorted.bam.bai
</code></pre>
<p>Once this single run completes successfully, you can confidently automate for all samples.</p>
<h3 id="step-3-automation-loop"><a class="header" href="#step-3-automation-loop">Step 3: Automation Loop</a></h3>
<p>After creating <code>sample_id.txt</code> (see <a href="02_geo_fastq_download.html#24-creating-sample-id-list">Step 2.4 in file 02</a>), here is the script to run this for all your samples:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

mkdir -p bowalign bowalign_log

while read -r sample; do
  echo "Aligning $sample"

  bowtie2 -x genome_index/ce_index \
    -U "fastq_cleaned/${sample}.clean.fastq.gz" \
    -p 6 --no-unal \
    2&gt; "bowalign_log/${sample}.bowtie2.log" \
    | samtools sort -@ 6 -o "bowalign/${sample}.sorted.bam"

  samtools index "bowalign/${sample}.sorted.bam"

done &lt; sample_id.txt
</code></pre>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Paired-end while loop</strong> (if your samples have _R1 and_R2 files):</p>
</blockquote>
<pre><code class="language-bash">while read -r sample; do
  echo "Aligning $sample"

  bowtie2 -x genome_index/ce_index \
    -1 "fastq_cleaned/${sample}_R1.clean.fastq.gz" \
    -2 "fastq_cleaned/${sample}_R2.clean.fastq.gz" \
    -p 6 --no-unal \
    2&gt; "bowalign_log/${sample}.log" | \
  samtools sort -@ 6 -o "bowalign/${sample}.sorted.bam"

  samtools index "bowalign/${sample}.sorted.bam"

done &lt; sample_id.txt
</code></pre>
<hr>
<h2 id="optimization"><a class="header" href="#optimization">Optimization</a></h2>
<h3 id="optimization-threads-vs-jobs"><a class="header" href="#optimization-threads-vs-jobs">Optimization: Threads vs. Jobs</a></h3>
<p>You have a limited number of CPU cores (computers brains). You can use them in two ways:</p>
<ol>
<li><strong>Multi-Threading (<code>-p 6</code>):</strong> One sample uses 6 cores. It finishes very fast, but you only do <strong>one sample at a time</strong>.
<ul>
<li><em>Best for:</em> Large genomes, low memory.</li>
</ul>
</li>
<li><strong>Parallel Jobs:</strong> You run <strong>3 samples</strong> at once, and each sample uses <strong>2 cores</strong>.
<ul>
<li><em>Best for:</em> Many small samples (RNA-seq, small genomes).</li>
</ul>
</li>
</ol>
<p><strong>Rule of Thumb:</strong> <code>bowtie2</code> stops getting faster after about <strong>8 threads</strong>. Don’t give it 50 threads; it’s a waste!</p>
<p><a href="https://www.jefftk.com/p/benchmarking-bowtie2-threading">Benchmarking Bowtie2 Threading - Jeff Kaufman (2023)</a></p>
<p><a href="https://wiki.csi.cuny.edu/HPCCWiki/BOWTIE2">BOWTIE2 - HPCC Wiki</a></p>
<p><a href="https://github.com/samtools/samtools/issues">Guidance with using multiple threads with samtools - GitHub</a></p>
<p><strong>Example with GNU Parallel</strong>:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

mkdir -p bowalign bowalign_log

parallel -j 2 '
  bowtie2 \
    -x genome_index/ce_index \
    -U fastq_cleaned/{}.clean.fastq.gz \
    -p 4 \
    --no-unal \
    2&gt; bowalign_log/{}.log \
  | samtools sort \
      -@ 2 \
      -m 1G \
      -o bowalign/{}.sorted.bam

  samtools index bowalign/{}.sorted.bam
' :::: sample_id.txt
</code></pre>
<p><strong>Effective CPU usage (implied by this setup):</strong></p>
<ul>
<li>2 parallel samples (<code>-j 2</code>)</li>
<li>Per sample: bowtie2 (4 threads, <code>-p 4</code>) + samtools sort (2 threads, <code>-@ 2</code>)</li>
<li>Total ≈ 12 threads → safe on a 16-core machine</li>
</ul>
<pre><code class="language-text">chipseq_tutorial/
├── fastq_raw/
├── fastq_cleaned/
├── fastp_reports/
├── genome_index/
├── bowalign/                ← Aligned BAM files
│   ├── H3K27me3_IP_rep1.sorted.bam
│   ├── H3K27me3_IP_rep1.sorted.bam.bai
│   └── ...
├── bowalign_log/            ← Alignment statistics
│   ├── H3K27me3_IP_rep1.log
│   └── ...
└── sample_id.txt
</code></pre>
<h3 id="understanding-bam-file-structure"><a class="header" href="#understanding-bam-file-structure">Understanding BAM File Structure</a></h3>
<p>Before we check alignment quality, let’s look at what’s inside a BAM file. BAM files store alignment information in a structured format with <strong>11 mandatory columns</strong>:</p>
<pre><code class="language-bash"># View the first few alignments in human-readable format
samtools view bowalign/H3K27me3_IP_rep1.sorted.bam | head -3
</code></pre>
<p><strong>Example output (single-end data):</strong></p>
<pre><code class="language-text">SRR7297994.1    0    I      15200    42    76M    *    0    0    ACGTACGT...    IIIIIIII...
SRR7297994.2    0    II     98432    30    76M    *    0    0    TGCATGCA...    IIIHHHHH...
SRR7297994.3   16    III    45123     0    76M    *    0    0    GATTACA...     IIIHHHGG...
</code></pre>
<p><strong>Column Breakdown (First 5 of 11 columns):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Column</th><th>Name</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>QNAME</td><td>SRR7297994.1</td><td>Read/Query name</td></tr>
<tr><td>2</td><td><strong>FLAG</strong></td><td>0, 16</td><td><strong>Bitwise FLAG</strong> (flagstat reads this!)</td></tr>
<tr><td>3</td><td>RNAME</td><td>I, II, III</td><td>Reference sequence name (chromosome)</td></tr>
<tr><td>4</td><td>POS</td><td>15200</td><td>Leftmost mapping position</td></tr>
<tr><td>5</td><td><strong>MAPQ</strong></td><td>42, 30, 0</td><td><strong>Mapping Quality score</strong> (0-255)</td></tr>
</tbody>
</table>
</div>
<p><strong>What Each QC Tool Evaluates:</strong></p>
<p><strong><code>samtools flagstat</code></strong> reads <strong>Column 2 (FLAG)</strong>:</p>
<ul>
<li>Bit 4: Read unmapped?</li>
<li>Bit 256: Secondary alignment?</li>
<li>Bit 1024: PCR/optical duplicate?</li>
<li>Bit 2048: Supplementary alignment?</li>
<li>And more… (see FLAG section below)</li>
</ul>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p><strong>Decode FLAGS:</strong> Use <a href="https://broadinstitute.github.io/picard/explain-flags.html">Explain SAM Flags</a> to understand bitwise FLAG values.</p>
</blockquote>
<h3 id="multimapping--the-lost-gps"><a class="header" href="#multimapping--the-lost-gps">Multimapping &amp; The “Lost GPS”</a></h3>
<p>Sometimes a read is repetitive (e.g., “ATATATAT”). It fits in 50 different places on the genome.
The aligner doesn’t know which spot is correct, so it gives it a <strong>Low MAPQ Score</strong> (Mapping Quality).
<strong>MAPQ filtering</strong> (<code>-q 30</code>) reads <strong>Column 5 (MAPQ)</strong>:</p>
<ul>
<li><strong>MAPQ = 0:</strong> “I have NO clue where this goes. It fits in many places.” (Multimapped)</li>
<li><strong>MAPQ &gt; 30:</strong> “I am highly confident this read belongs EXACTLY here.” (Unique)</li>
</ul>
<h3 id="quality-check-samtools-flagstat--samtools-stats"><a class="header" href="#quality-check-samtools-flagstat--samtools-stats">Quality Check: <code>samtools flagstat</code> &amp; <code>samtools stats</code></a></h3>
<p>Did the alignment work? Let’s check the score using two tools:</p>
<ul>
<li><strong>flagstat</strong>: Quick alignment summary (mapped reads, pairs, etc.)</li>
<li><strong>stats</strong>: Comprehensive metrics including MAPQ distribution (for MultiQC visualization)</li>
</ul>
<pre><code class="language-bash"># Create QC output directory for alignment metrics
mkdir -p bowalign_qc

# Quick summary with flagstat
samtools flagstat bowalign/H3K27me3_IP_rep1.sorted.bam &gt; bowalign_qc/H3K27me3_IP_rep1.flagstat.txt

# Comprehensive stats (includes MAPQ distribution for MultiQC)
samtools stats bowalign/H3K27me3_IP_rep1.sorted.bam &gt; bowalign_qc/H3K27me3_IP_rep1.stats.txt
</code></pre>
<p><strong>Batch processing for all samples:</strong></p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

mkdir -p bowalign_qc

while read -r sample; do
  echo "Running QC for: $sample"
  
  # Generate flagstat summary
  samtools flagstat bowalign/${sample}.sorted.bam &gt; bowalign_qc/${sample}.flagstat.txt
  
  # Generate comprehensive stats (for MultiQC)
  samtools stats bowalign/${sample}.sorted.bam &gt; bowalign_qc/${sample}.stats.txt
  
done &lt; sample_id.txt

# Generate MultiQC report with all QC results
echo "Generating MultiQC report..."
multiqc bowalign_qc/ -o bowalign_qc/ -n alignment_qc_report
echo "MultiQC report saved: bowalign_qc/alignment_qc_report.html"
</code></pre>
<p>This creates an interactive HTML report (<code>alignment_qc_report.html</code>) with visualizations of alignment metrics across all samples, including MAPQ distribution plots.</p>
<hr>
<p><strong>What to look for:</strong></p>
<ul>
<li><strong>Mapping Rate:</strong> Ideally <strong>&gt;80-90%</strong>. If it’s &lt;50%, your DNA might be contaminated (e.g., bacteria in a sample).</li>
<li><strong>Goal:</strong> High mapping percentage indicates good quality alignment.</li>
<li><strong>Warning:</strong> If mapping is low (&lt;50%), you may have the wrong organism or bad sequencing.</li>
</ul>
<p><strong>The Sensitivity-Specificity Trade-off:</strong></p>
<p>Multi-mapping reads critically influence the balance between sensitivity and specificity in ChIP-seq peak detection. Excluding multi-mappers, standard practice in most peak callers, improves specificity by preventing artificial signal inflation in repetitive regions but reduces sensitivity for genuine binding events within those regions (<a href="https://www.encodeproject.org/">ENCODE Project Consortium, 2012</a>). This trade-off is acceptable for transcription factors and chromatin features predominantly in unique genomic loci. However, repetitive and transposable elements (REs/TEs) constitute significant genome portions with important regulatory roles, and discarding multi-mapped reads substantially underrepresents regulatory events in these regions (<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/">He et al., 2022</a>). For studies involving repetitive elements or broad chromatin domains, alternative strategies include paired-end sequencing (reduces mapping ambiguity), probabilistic allocation methods like <em>Allo</em> and <em>MuMRescueLite</em> (allocate reads based on uniquely mapped read distributions), or consensus sequence mapping (family-level TE insights) (<a href="https://academic.oup.com/">Chung et al., 2011</a>; <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/">He et al., 2022</a>). Caution is advised as improper use can lead to double-counting and false positives.</p>
<h4 id="quick-manual-mapq-check"><a class="header" href="#quick-manual-mapq-check">Quick Manual MAPQ Check</a></h4>
<p>For a <strong>quick manual inspection</strong> of MAPQ distribution (complementary to the MultiQC visualization):</p>
<pre><code class="language-bash">samtools view bowalign/H3K27me3_IP_rep1.sorted.bam | awk '{print $5}' | sort -n | uniq -c &gt; bowalign_qc/H3K27me3_IP_rep1.mapq.txt
</code></pre>
<p><strong>Understanding the Manual Output:</strong></p>
<ul>
<li><strong>If you see lots of 0s:</strong> Your file includes “Lost GPS” reads (Multimappers).</li>
<li><strong>If your scores start at 30+:</strong> Your file has <strong>Already Filtered</strong> the bad reads.</li>
</ul>
<p><strong>Output format: <code>count</code> <code>MAPQ_score</code></strong></p>
<pre><code class="language-text">123964  30  &lt;-- Lowest score is 30 (Good confidence)
1928 31
20741 32
1477 33
4040 34
34434 35
14294 36
53329 37
30665 38
88528 39
77123 40
2960636 42  &lt;-- Highest score is 42 (Perfect confidence)
</code></pre>
<p><em>Verdict: This BAM file contains only uniquely mapped, high-quality reads.</em></p>
<hr>
<h3 id="filtering-multi-mapping-reads"><a class="header" href="#filtering-multi-mapping-reads">Filtering Multi-mapping Reads</a></h3>
<p>For standard ChIP-seq analysis (TFs, histone marks in unique regions), filter BAM files to retain only high-quality uniquely mapped reads:</p>
<pre><code class="language-bash"># Create directory for filtered BAM files
mkdir -p bowalign_filtered

# Filter out multi-mappers (keep only MAPQ ≥ 30)
samtools view -b -q 30 bowalign/H3K27me3_IP_rep1.sorted.bam &gt; bowalign_filtered/H3K27me3_IP_rep1.filtered.bam

# Index the filtered BAM
samtools index bowalign_filtered/H3K27me3_IP_rep1.filtered.bam
</code></pre>
<p><strong>Batch processing for all samples:</strong></p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

mkdir -p bowalign_filtered

while read -r sample; do
  echo "Filtering multi-mappers for: $sample"
  samtools view -b -q 30 bowalign/${sample}.sorted.bam &gt; bowalign_filtered/${sample}.filtered.bam
  samtools index bowalign_filtered/${sample}.filtered.bam
done &lt; sample_id.txt
</code></pre>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>The <code>-q 30</code> flag filters out reads with MAPQ &lt; 30 (removes multi-mappers and low-confidence alignments). Most downstream tools (MACS2, deepTools) can also filter by MAPQ, so this step is optional but recommended for cleaner data.</p>
</blockquote>
<hr>
<h3 id="directory-structure-after-alignment-qc"><a class="header" href="#directory-structure-after-alignment-qc">Directory Structure After Alignment QC</a></h3>
<pre><code class="language-text">chipseq_tutorial/
├── fastq_raw/
├── fastq_cleaned/
├── genome_index/
├── bowalign/                    ← Aligned BAM files
│   ├── H3K27me3_IP_rep1.sorted.bam
│   ├── H3K27me3_IP_rep1.sorted.bam.bai
│   └── ...
├── bowalign_log/                ← Alignment statistics
│   ├── H3K27me3_IP_rep1.log
│   └── ...
├── bowalign_qc/                 ← Quality control metrics
│   ├── H3K27me3_IP_rep1.flagstat.txt
│   ├── H3K27me3_IP_rep1.stats.txt
│   ├── H3K27me3_IP_rep1.mapq.txt
│   ├── alignment_qc_report.html
│   ├── alignment_qc_report_data/
│   └── ...
├── bowalign_filtered/           ← Filtered BAM files (MAPQ ≥ 30)
│   ├── H3K27me3_IP_rep1.filtered.bam
│   ├── H3K27me3_IP_rep1.filtered.bam.bai
│   └── ...
└── sample_id.txt
</code></pre>
<hr>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<ol>
<li><strong>Analogy:</strong> Alignment is placing puzzle pieces onto the reference picture.</li>
<li><strong>Action:</strong> Use <code>bowtie2</code> to align and <code>samtools sort</code> to organize.</li>
<li><strong>Result:</strong> A <strong>Sorted BAM</strong> file (the solved puzzle), ready for peak calling.</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> Before peak calling, we need to remove PCR duplicates and assess library quality.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="handling-duplicates--quality-control"><a class="header" href="#handling-duplicates--quality-control">Handling Duplicates &amp; Quality Control</a></h1>
<p><code>PCR-duplicates</code> <code>optical-duplicates</code> <code>Picard</code> <code>samtools</code> <code>MarkDuplicates</code> <code>deduplication</code> <code>read-groups</code> <code>MultiQC</code></p>
<h2 id="1-basic-concept-the-photocopier-analogy"><a class="header" href="#1-basic-concept-the-photocopier-analogy">1. Basic Concept: The “Photocopier” Analogy</a></h2>
<p>Imagine you are trying to read a rare, handwritten manuscript (your DNA sample). You want to digitize it, so you take photos (sequencing reads) of different pages.</p>
<ul>
<li><strong>Real Signal (Enriched Regions):</strong> If many people are taking photos of the <em>same important page</em> because it’s interesting, that’s good! In ChIP-seq, this happens when a protein binds strongly to a specific DNA spot. We see many reads there because the biological signal is strong.</li>
<li><strong>Duplicates (Artifacts):</strong> Now, imagine the photocopier gets stuck and prints 100 copies of a <em>random, unimportant page</em> just because of a machine error. These copies don’t mean that page is 100 times more important; they are just <strong>junk</strong>. In sequencing, this is called <strong>PCR duplication</strong>—where the chemistry accidentally over-copies a single DNA fragment.</li>
</ul>
<p><strong>Goal:</strong> We want to keep the “popular pages” (real biological signal) but throw away the “accidental machine copies” (PCR duplicates) so they don’t trick us into thinking a random spot is important.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Two Tools, Same Goal:</strong> This chapter covers two methods for duplicate removal. <strong>Picard</strong> (Section 3) offers fine-grained control with read groups and optical duplicate detection—ideal for complex multi-replicate studies. <strong>Samtools</strong> (Section 4) provides a simpler, single-pipeline approach—sufficient for most ChIP-seq analyses. Choose the method that fits your workflow.</p>
</blockquote>
<hr>
<h2 id="2-understanding-the-details"><a class="header" href="#2-understanding-the-details">2. Understanding the Details</a></h2>
<p>For those who want to understand the “under the hood” mechanics, here is what are different types of duplicates and  the Read Groups .</p>
<h3 id="pcr-vs-optical-duplicates"><a class="header" href="#pcr-vs-optical-duplicates">PCR vs. Optical Duplicates</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Origin</th><th>Typical Cause</th><th>Implication</th></tr>
</thead>
<tbody>
<tr><td><strong>PCR Duplicates</strong></td><td>Library Prep</td><td>Over-cycling (amplifying DNA too much)</td><td>Shows low library complexity (not enough unique DNA to start with).</td></tr>
<tr><td><strong>Optical Duplicates</strong></td><td>Sequencer</td><td>Camera errors reads the same cluster as two</td><td>Technical glitch on the flow cell.</td></tr>
</tbody>
</table>
</div>
<h3 id="the-role-of-read-groups-rg"><a class="header" href="#the-role-of-read-groups-rg">The Role of Read Groups (RG)</a></h3>
<p>A <strong>Read Group</strong> is a tag that tells the software “this read came from Sample A, Run 1.”</p>
<ul>
<li><strong>Why is it vital?</strong> If you merge two different samples (e.g., Replicate 1 and Replicate 2), you might have two different reads that coincidentally map to the same spot.</li>
<li>Without Read Groups, Picard acts blindly: “These look identical! Delete one!” -&gt; <strong>Data Loss.</strong></li>
<li>With Read Groups, Picard sees: “Oh, one is from Replicate 1 and one is from Replicate 2. They are different samples. Keep both!”</li>
</ul>
<p>*<strong>Full hierarchy in RGing</strong></p>
<pre><code class="language-text">RGSM  → biological sample (Control H3k9ac)
  └── RGLB → library prep (usually lib1 however if Different library preps (even from same sample) RGLB=lib1 RGLB=lib2 )
        └── RGPU → flowcell + lane (from header of Fastq file )
              └── RGID → unique ID tying it all together (replicates: H3K27me3_IP_rep1, H3K27me3_IP_rep2)


</code></pre>
<h2 id="3-marking--removing-duplicates-why-picard-is-unique"><a class="header" href="#3-marking--removing-duplicates-why-picard-is-unique">3. Marking &amp; Removing Duplicates: Why Picard is Unique</a></h2>
<p><strong>Picard</strong> stands out among duplicate-marking tools because it:</p>
<ul>
<li>Distinguishes <strong>optical vs. PCR duplicates</strong> during QC reporting.</li>
<li>Leverages <strong>read group (RG) identifiers</strong> to avoid over-collapsing reads when combining multiple replicates or lanes.</li>
<li>Provides metrics for each library or sample, enabling fine-grained quality control.</li>
</ul>
<p>Picard’s RG-aware logic ensures duplicates are flagged <strong>within</strong>, but not <strong>across</strong>, biological replicates or lanes — preventing false duplicate marking when BAMs are merged.</p>
<hr>
<h1 id="31-adding-rgs-to-each-bam-file"><a class="header" href="#31-adding-rgs-to-each-bam-file">3.1 Adding RGs to each Bam file</a></h1>
<p><strong>Minimal augmented RG setup (merge BAM replicates)</strong></p>
<p>This read-group configuration is designed for the simplest defensible case: merging biological or technical ChIP-seq replicates and proceeding directly to peak calling.</p>
<p><strong>Input files needed:</strong></p>
<ul>
<li>Filtered BAM file: <code>bowalign_filtered/H3K27me3_IP_rep1.filtered.bam</code> (from section 05)</li>
</ul>
<pre><code class="language-bash">mkdir -p picard_rg_bam

picard AddOrReplaceReadGroups \
  I=bowalign_filtered/H3K27me3_IP_rep1.filtered.bam \
  O=picard_rg_bam/H3K27me3_IP_rep1.RG.bam \
  RGID=H3K27me3_IP_rep1 \
  RGSM=H3K9ac
</code></pre>
<p><strong>What this does:</strong></p>
<ul>
<li><strong>I=</strong> specifies the input BAM file from the alignment step</li>
<li><strong>O=</strong> specifies the output BAM file with read-group tags added</li>
<li><strong>RGID=</strong> sets a unique Read Group ID (one per replicate)</li>
<li><strong>RGSM=</strong> sets the biological sample name (used for grouping replicates)</li>
</ul>
<p><strong>Minimal augmented RG setup (optical duplicates enabled)</strong></p>
<p>This configuration extends the previous one by adding the minimum required metadata to make optical duplicate detection meaningful.
The addition of RGPU, encoding the flowcell and lane, defines the physical neighborhood in which optical duplicates can occur.</p>
<pre><code class="language-bash">picard AddOrReplaceReadGroups \
  I=bowalign_filtered/H3K27me3_IP_rep1.filtered.bam \     # Input: MAPQ-filtered BAM from section 05
  O=picard_rg_bam/H3K27me3_IP_rep1.RG.bam \           # Output with RG tags
  RGID=H3K27me3_IP_rep1 \                      # Read Group ID
  RGSM=H3K9ac \                          # Biological sample
  RGPL=ILLUMINA \                        # REQUIRED for optical duplicate logic
  RGPU=CA0TUACXX.1                       # REQUIRED: flowcell.lane (from FASTQ header)
</code></pre>
<p>More from <a href="https://broadinstitute.github.io/picard/command-line-overview.html#AddOrReplaceReadGroups">GATK: Read Groups</a>
<a href="https://gatk.broadinstitute.org/hc/en-us/articles/360037052812-MarkDuplicates-Picard">Picard markduplicates</a></p>
<h3 id="step-32-mark-duplicates-be-careful"><a class="header" href="#step-32-mark-duplicates-be-careful">Step 3.2: Mark Duplicates (Be Careful!)</a></h3>
<p>First, we will just <strong>mark</strong> the duplicates but <strong>keep them</strong> in the file. This is like highlighting the duplicate pages in yellow but not throwing them in the trash yet. This is important for Quality Control (QC) to see how bad the duplication problem is.</p>
<p><strong>Input files needed:</strong></p>
<ul>
<li>Filtered BAM file with read groups: <code>picard_rg_bam/H3K27me3_IP_rep1.RG.bam</code></li>
</ul>
<pre><code class="language-bash"># ----- 3.3 Mark duplicates (keep all reads, just mark) -----

mkdir -p picard_markdup picard_markdup_metrics

# Run Picard MarkDuplicates
picard MarkDuplicates \
  I=picard_rg_bam/H3K27me3_IP_rep1.RG.bam \
  O=picard_markdup/H3K27me3_IP_rep1.marked.bam \
  M=picard_markdup_metrics/H3K27me3_IP_rep1.metrics.txt \
  REMOVE_DUPLICATES=false

# Index the new file
samtools index picard_markdup/H3K27me3_IP_rep1.marked.bam
</code></pre>
<p><strong>What this does:</strong></p>
<ul>
<li><strong>I=</strong> specifies input BAM file with read groups</li>
<li><strong>O=</strong> specifies output BAM file with duplicates marked (not removed)</li>
<li><strong>M=</strong> creates metrics file reporting duplicate statistics</li>
<li><strong>REMOVE_DUPLICATES=false</strong> marks duplicates but keeps all reads in the file</li>
<li><strong>samtools index</strong> creates index for marked BAM file</li>
</ul>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p><strong>Why keep marked files?</strong> The Picard metrics file (<code>.metrics.txt</code>) contains duplicate rates that <strong>MultiQC</strong> can aggregate into summary reports. However, for <strong>downstream analysis (peak calling, BigWig generation)</strong>, always use the <strong>deduplicated BAMs</strong> to prevent PCR artifacts from inflating your signal.</p>
<p><em>Note:</em> While MACS can handle duplicates internally via <code>--keep-dup</code> options, using pre-deduplicated BAMs is the recommended practice—it gives you explicit control and avoids relying on MACS’s position-based duplicate detection, which differs from Picard/samtools fragment-level detection. [<a href="https://github.com/macs3-project/MACS/issues/33">GitHub #33</a>] [<a href="https://www.biostars.org/p/318974/#319028">Biostars</a>]</p>
</blockquote>
<p><strong>Aggregate metrics with MultiQC:</strong></p>
<pre><code class="language-bash"># Run MultiQC on Picard metrics folder
multiqc picard_dedup_metrics/ -o multiqc_report/
</code></pre>
<p>This generates an interactive HTML report showing duplicate rates across all samples.</p>
<h3 id="step-33-remove-duplicates-clean-up"><a class="header" href="#step-33-remove-duplicates-clean-up">Step 3.3: Remove Duplicates (Clean Up)</a></h3>
<p>Now that we’ve checked the quality, we create a “clean” version of our data for analysis. We remove the marked duplicates so they don’t interfere with peak calling.</p>
<pre><code class="language-bash"># ----- 3.4 Create a duplicate-removed BAM by filtering marked BAM -----

mkdir -p picard_dedup_bam picard_dedup_metrics

# Run Picard to REMOVE duplicates
picard MarkDuplicates \
  I=picard_rg_bam/H3K27me3_IP_rep1.RG.bam \
  O=picard_dedup_bam/H3K27me3_IP_rep1.dedup.bam \
  M=picard_dedup_metrics/H3K27me3_IP_rep1.metrics.txt \
  REMOVE_DUPLICATES=true

# Index the new file
samtools index picard_dedup_bam/H3K27me3_IP_rep1.dedup.bam
</code></pre>
<ul>
<li><code>REMOVE_DUPLICATES=true</code>: This time, we actually delete the highlighted duplicates.</li>
</ul>
<h3 id="after-picard-deduplication"><a class="header" href="#after-picard-deduplication">After Picard Deduplication</a></h3>
<pre><code class="language-text">chipseq_tutorial/
├── fastq_raw/
├── fastq_cleaned/
├── genome_index/
├── bowalign/                    ← Aligned BAMs
├── bowalign_filtered/           ← Filtered BAMs
├── picard_rg_bam/               ← BAMs with Read Groups
│   ├── H3K27me3_IP_rep1.RG.bam
│   ├── H3K27me3_IP_rep1.RG.bam.bai
│   └── ...
├── picard_dedup_bam/            ← Final Deduplicated BAMs
│   ├── H3K27me3_IP_rep1.dedup.bam
│   ├── H3K27me3_IP_rep1.dedup.bam.bai
│   └── ...
├── picard_metrics/              ← Duplication Reports
│   ├── H3K27me3_IP_rep1.metrics.txt
│   └── ...
└── sample_id.txt
</code></pre>
<hr>
<h2 id="4-samtools-simple-alternative"><a class="header" href="#4-samtools-simple-alternative">4. Samtools (Simple Alternative)</a></h2>
<p>Samtools provides a lightweight and reliable way to handle duplicates without the complexity of read groups. Choose this option if you want a straightforward workflow.</p>
<h3 id="step-41-prepare-bam-for-duplicate-detection"><a class="header" href="#step-41-prepare-bam-for-duplicate-detection">Step 4.1: Prepare BAM for Duplicate Detection</a></h3>
<pre><code class="language-bash"># Paired-end mates are placed next to each other. Groups reads by read name
samtools collate -o temp/H3K27me3_IP_rep1.collate.bam bowalign_filtered/H3K27me3_IP_rep1.filtered.bam

# Synchronize mate flags and add mate-related tags
samtools fixmate -m temp/H3K27me3_IP_rep1.collate.bam temp/H3K27me3_IP_rep1.fixmate.bam

# Coordinate sort for duplicate marking
samtools sort -o temp/H3K27me3_IP_rep1.positionsort.bam temp/H3K27me3_IP_rep1.fixmate.bam
</code></pre>
<h3 id="step-42-mark-duplicates-keep-for-qc"><a class="header" href="#step-42-mark-duplicates-keep-for-qc">Step 4.2: Mark Duplicates (Keep for QC)</a></h3>
<pre><code class="language-bash"># Mark duplicates but KEEP them in the output
samtools markdup temp/H3K27me3_IP_rep1.positionsort.bam samtools_markdup/H3K27me3_IP_rep1.marked.bam

# Index the file
samtools index samtools_markdup/H3K27me3_IP_rep1.marked.bam
</code></pre>
<h3 id="step-43-remove-duplicates-clean-for-analysis"><a class="header" href="#step-43-remove-duplicates-clean-for-analysis">Step 4.3: Remove Duplicates (Clean for Analysis)</a></h3>
<pre><code class="language-bash"># Remove duplicates with -r flag
samtools markdup -r temp/H3K27me3_IP_rep1.positionsort.bam samtools_dedup_bam/H3K27me3_IP_rep1.dedup.bam

# Index the file
samtools index samtools_dedup_bam/H3K27me3_IP_rep1.dedup.bam
</code></pre>
<p>This samtools-based workflow is simpler than Picard and avoids the need for read-group metadata, while still providing accurate duplicate detection for paired-end data.</p>
<h3 id="step-44-automation-loop-all-samples"><a class="header" href="#step-44-automation-loop-all-samples">Step 4.4: Automation Loop (All Samples)</a></h3>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

mkdir -p samtools_dedup_bam

while read -r sample; do
  echo "Processing $sample..."

  # All steps piped together - no temp files needed!
  samtools collate -u -O "bowalign_filtered/${sample}.filtered.bam" | \
    samtools fixmate -m -u - - | \
    samtools sort -u - | \
    samtools markdup -r - "samtools_dedup_bam/${sample}.dedup.bam"

  # Index the final output
  samtools index "samtools_dedup_bam/${sample}.dedup.bam"

  echo "Finished $sample"
done &lt; sample_id.txt
</code></pre>
<p><strong>Why use pipes?</strong></p>
<pre><code>collate → fixmate → sort → markdup
  ↓         ↓        ↓       ↓
 pipe     pipe     pipe    file
</code></pre>
<ul>
<li><strong><code>-u</code> flag</strong>: Outputs uncompressed BAM for faster streaming between commands</li>
<li><strong><code>-</code> symbol</strong>: Represents stdin/stdout, allowing data to flow through the pipeline</li>
<li><strong>No temp files</strong>: Everything processes in memory, saving disk space and I/O time</li>
<li><strong>Faster</strong>: No waiting for disk writes between each step</li>
</ul>
<p>More <a href="https://www.htslib.org/algorithms/duplicate.html">samtools</a></p>
<h3 id="after-samtools-deduplication"><a class="header" href="#after-samtools-deduplication">After Samtools Deduplication</a></h3>
<pre><code class="language-text">chipseq_tutorial/
├── bowalign_filtered/           ← Input: MAPQ-filtered BAM files (from section 05)
│   ├── H3K27me3_IP_rep1.filtered.bam
│   └── ...
├── samtools_markdup/            ← Duplicates marked (not removed)
│   ├── H3K27me3_IP_rep1.marked.bam
│   └── ...
├── samtools_dedup_bam/          ← Duplicates removed
│   ├── H3K27me3_IP_rep1.dedup.bam
│   ├── H3K27me3_IP_rep1.dedup.bam.bai
│   └── ...
└── sample_id.txt
</code></pre>
<hr>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<ol>
<li><strong>Understand:</strong> PCR duplicates inflate signal artificially; we mark/remove them.</li>
<li><strong>Action:</strong> Use Picard (with read groups) or samtools to handle duplicates.</li>
<li><strong>Result:</strong> Clean, deduplicated BAM files ready for peak calling.</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> We’ll assess library complexity to understand how deeply our libraries were sequenced.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="library-complexity-the-street-photographer"><a class="header" href="#library-complexity-the-street-photographer">Library Complexity (The “Street Photographer”)</a></h1>
<p><code>library-complexity</code> <code>NRF</code> <code>PBC</code> <code>PCR-duplicates</code> <code>bedtools</code> <code>unique-reads</code> <code>QC-metrics</code></p>
<h2 id="level-1-basic-concept-the-photographer"><a class="header" href="#level-1-basic-concept-the-photographer">Level 1: Basic Concept (The Photographer)</a></h2>
<p>Imagine you are a <strong>Street Photographer</strong> in a busy city. Your goal is to capture the diversity of the population.</p>
<ul>
<li><strong>High Complexity Library (Good):</strong> You take 100 photos, and every photo shows a different person. You have captured the true variety of the city.</li>
<li><strong>Low Complexity Library (Bad):</strong> You take 100 photos, but it’s just the same person 100 times. You wasted your film (sequencing reads) on duplicates.</li>
</ul>
<p>In ChIP-seq, if we keep sequencing the exact same DNA fragment over and over (PCR duplicates), we aren’t learning anything new. We want a “Complex” library with many unique fragments.</p>
<hr>
<h2 id="level-2-execution-the-calculator"><a class="header" href="#level-2-execution-the-calculator">Level 2: Execution (The Calculator)</a></h2>
<p>We calculate complexity using metrics called <strong>NRF</strong> and <strong>PBC</strong>.
This calculation is a bit complex, so we use a script that combines <code>bedtools</code>, <code>sort</code>, and <code>awk</code>.</p>
<p><strong>Input files needed:</strong></p>
<pre><code class="language-text">chipseq_tutorial/
├── picard_dedup_bam/
│   ├── H3K27me3_IP_rep1.dedup.bam
│   └── ...
├── QC_results/
│   ├── H3K27me3_IP_rep1.pbc.txt
│   └── ...
└── sample_id.txt
</code></pre>
<p><strong>Run this command block for one sample:</strong></p>
<pre><code class="language-bash">mkdir -p QC_results

# 1. Create a "5-prime" BED file
# (Convert BAM to simple coordinates, keeping only the start position of each read)
bedtools bamtobed -i picard_dedup_bam/H3K27me3_IP_rep1.dedup.bam \
  | awk 'BEGIN{OFS="\t"} ($6=="+"){print $1,$2,$2+1} ($6=="-"){print $1,$3-1,$3}' \
  | sort -k1,1 -k2,2n \
  &gt; QC_results/Sample1.read5.bed

# 2. Compute NRF, PBC1, PBC2
# (Count how many times each position appears)
uniq -c QC_results/Sample1.read5.bed \
  | awk '{c=$1; total+=c; uniq++; if(c==1) single++; if(c==2) double++;} \
    END{ if(total==0){print "NRF=NA\tPBC1=NA\tPBC2=NA"; exit} \
    NRF=uniq/total; \
    PBC1=single/uniq; \
    PBC2=(double? single/double:"Inf"); \
    printf("NRF=%.3f\tPBC1=%.3f\tPBC2=%s\n", NRF, PBC1, PBC2); }' \
  &gt; QC_results/Sample1.pbc.txt
</code></pre>
<p><strong>Check the result:</strong></p>
<pre><code class="language-bash">cat QC_results/Sample1.pbc.txt
</code></pre>
<pre><code class="language-text">NRF=0.997 PBC1=0.997 PBC2=360.061
</code></pre>
<hr>
<h3 id="understanding-the-metrics"><a class="header" href="#understanding-the-metrics">Understanding the Metrics</a></h3>
<ul>
<li><strong>NRF (Non-Redundant Fraction):</strong><br><code>Unique Reads / Total Reads</code>. (Ideal: &gt; 0.8)</li>
<li><strong>PBC1 (PCR Bottleneck Coefficient 1):</strong><br><code>Genomic positions with 1 read / Genomic positions with ≥1 read</code>. (Ideal: &gt; 0.8)</li>
<li><strong>PBC2 (PCR Bottleneck Coefficient 2):</strong><br><code>Positions with 1 read / Positions with 2 reads</code>. (Ideal: &gt; 3.0)</li>
</ul>
<h3 id="encode-guidelines"><a class="header" href="#encode-guidelines">ENCODE Guidelines</a></h3>
<p>How good is your library? Use this chart from ENCODE to grade your data.</p>
<img width="1126" height="275" alt="Screenshot 2025-11-26 at 11 20 56 AM" src="https://github.com/user-attachments/assets/730d3662-6973-4a4e-a9f9-fe565583ed32" />
<p><a href="https://www.encodeproject.org/data-standards/terms/#library"><em>Source: ENCODE Data Standards</em></a></p>
<h3 id="before-vs-after-deduplication"><a class="header" href="#before-vs-after-deduplication">Before vs. After Deduplication</a></h3>
<p><strong>Crucial Concept:</strong><br>Raw data often looks “Low Complexity” just because of PCR duplicates. This is misleading. Once you remove the duplicates, the remaining data reveals the <em>true</em> quality of your library.</p>
<p><strong>Example Comparison:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Stage</th><th style="text-align: left">NRF</th><th style="text-align: left">PBC1</th><th style="text-align: left">PBC2</th><th style="text-align: left">Interpretation</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><strong>Before</strong> Removal</td><td style="text-align: left">0.668</td><td style="text-align: left">0.695</td><td style="text-align: left">3.3</td><td style="text-align: left">Appears “Moderate/Low” quality due to duplicates.</td></tr>
<tr><td style="text-align: left"><strong>After</strong> Removal</td><td style="text-align: left"><strong>0.952</strong></td><td style="text-align: left"><strong>0.949</strong></td><td style="text-align: left"><strong>18.6</strong></td><td style="text-align: left">Use these values! True library is <strong>High Quality</strong>.</td></tr>
</tbody>
</table>
</div>
<p><strong>Lesson:</strong> Don’t panic if your raw NRF is low. Remove duplicates first, then check again.</p>
<hr>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<ol>
<li><strong>Goal:</strong> Ensure we have many unique DNA fragments (High Complexity).</li>
<li><strong>Action:</strong> Run the NRF/PBC calculation script.</li>
<li><strong>Result:</strong> Compare your numbers against the ENCODE chart to validate your experiment.</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> We’ll dive deeper into BAM quality metrics to assess alignment quality and fragment sizes.</p>
</blockquote>
<hr>
<h2 id="pipeline-summary-pre-processing-workflow-complete"><a class="header" href="#pipeline-summary-pre-processing-workflow-complete">Pipeline Summary: Pre-processing Workflow Complete</a></h2>
<p>Congratulations! You have completed the core ChIP-seq pre-processing workflow from raw sequencing reads to analysis-ready BAM files.</p>
<p><strong>Pre-processing Pipeline:</strong></p>
<ul>
<li><strong><a href="02_geo_fastq_download.html">FASTQ Acquisition</a>:</strong> Downloaded from GEO/SRA (C. elegans H3K27me3 ChIP-seq, single-end reads)</li>
<li><strong><a href="03_sample_list_creation.html">Sample Manifest</a>:</strong> Created sample ID list for batch processing</li>
<li><strong><a href="#understanding-and-cleaning-your-data-fastq--fastp">Quality Control</a>:</strong> Read quality assessment and adapter trimming (fastp)</li>
<li><strong><a href="#alignment-solving-the-jigsaw-puzzle">Genome Alignment</a>:</strong> Mapped reads to reference assembly (Bowtie2, single-end mode)</li>
<li><strong><a href="#handling-duplicates--quality-control">Duplicate Removal</a>:</strong> PCR duplicate identification and removal (Picard MarkDuplicates)</li>
<li><strong><a href="#library-complexity-the-street-photographer">Library Complexity</a>:</strong> QC assessment with NRF, PBC1, PBC2 metrics</li>
</ul>
<p><strong>Analysis-ready outputs:</strong></p>
<ul>
<li>Deduplicated, coordinate-sorted BAM files with index (.bai)</li>
<li>Per-sample QC metrics (alignment rate, duplication rate, complexity)</li>
<li>Quality-filtered reads ready for peak calling</li>
</ul>
<hr>
<h2 id="transition-to-encode-bam-files"><a class="header" href="#transition-to-encode-bam-files">Transition to ENCODE BAM Files</a></h2>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p><strong>For downstream analysis</strong>, we will use <strong>pre-processed BAM files from ENCODE</strong> instead of the files we generated during pre-processing.</p>
<p><strong>Why?</strong></p>
<ul>
<li>ENCODE provides high-quality, standardized ChIP-seq data</li>
<li>Files are already aligned, deduplicated, and quality-controlled</li>
<li>This allows us to focus on downstream analysis (peak calling, visualization, annotation)</li>
</ul>
<p><strong>What this means:</strong></p>
<ul>
<li>The pre-processing workflow taught you complete data preparation from raw reads to analysis-ready BAM</li>
<li>Downstream analysis will use ENCODE BAM files for demonstration</li>
<li>You can apply both approaches: process your own data OR use public ENCODE data</li>
</ul>
</blockquote>
<p>The skills you learned in the pre-processing workflow are valuable for processing your own ChIP-seq data. For the remaining tutorials, we’ll demonstrate downstream analysis using ENCODE’s curated datasets.</p>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p><strong>Challenge yourself!</strong> Before moving to downstream analysis, consider applying the downstream analysis steps (peak calling, visualization, annotation) to your C. elegans H3K27me3 data from the pre-processing workflow. This hands-on practice will solidify your understanding and give you complete end-to-end ChIP-seq analysis experience. You can then compare your results with the ENCODE workflow!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="experiment-design--bam-quality-control"><a class="header" href="#experiment-design--bam-quality-control">Experiment Design &amp; BAM Quality Control</a></h1>
<p><code>ENCODE</code> <code>BAM-files</code> <code>samtools</code> <code>flagstat</code> <code>MAPQ</code> <code>quality-control</code> <code>alignment-QC</code> <code>deepTools</code> <code>single-end</code></p>
<h2 id="1-basic-concept-the-experiment--the-file"><a class="header" href="#1-basic-concept-the-experiment--the-file">1. Basic Concept (The Experiment &amp; The File)</a></h2>
<h3 id="11-the-experiment-story"><a class="header" href="#11-the-experiment-story">1.1 The Experiment Story</a></h3>
<p>This tutorial uses real data from <strong>BLaER1 cells</strong> (human immune cells).</p>
<ul>
<li><strong>Treatment:</strong> Cells were treated for 18 hours with Estradiol, Interleukin-3, and CSF1 to activate specific genes.</li>
<li><strong>The Targets:</strong>
<ol>
<li><strong>CEBPA:</strong> A Transcription Factor (The “Driver” that turns on genes).</li>
<li><strong>H3K27me3:</strong> A Histone Mark for <strong>Closed/Repressed</strong> DNA (The “Stop Sign”).</li>
<li><strong>H3K9ac:</strong> A Histone Mark for <strong>Open/Active</strong> DNA (The “Go Sign”).</li>
<li><strong>Input:</strong> Random background DNA (The “Noise” control).</li>
</ol>
</li>
</ul>
<h3 id="12-the-zip-file-analogy-bam-vs-sam"><a class="header" href="#12-the-zip-file-analogy-bam-vs-sam">1.2 The “Zip File” Analogy (BAM vs SAM)</a></h3>
<ul>
<li><strong>SAM File (Sequence Alignment Map):</strong> This is a huge, readable text file. It’s like a 1000-page printed manuscript.</li>
<li><strong>BAM File (Binary Alignment Map):</strong> This is the <strong>Compressed Zip File</strong> version. It contains the exact same info but is smaller and faster for the computer to read.
<ul>
<li><em>Rule:</em> We always work with BAM files to save space and time.</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Data Availability:</strong></p>
<ul>
<li><a href="https://www.encodeproject.org/carts/ca521f95-7835-4369-88a9-b89f98fb39ad/">ENCODE Cart</a></li>
</ul>
<h2 id="2-data-used-in-the-tutorial"><a class="header" href="#2-data-used-in-the-tutorial">2. Data used in the tutorial</a></h2>
<h3 id="21-sample-table"><a class="header" href="#21-sample-table">2.1 Sample Table</a></h3>
<p>Here are the files we are analyzing. In real life, you should make a table like this to track your work.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Biosample Accession</th><th>ChIP Type</th><th>Target</th><th>Custom BAM Filename</th></tr>
</thead>
<tbody>
<tr><td>ENCFF327JFG</td><td>TF ChIP-seq</td><td>CEBPA</td><td>ceb_ENCFF327JFG.bam</td></tr>
<tr><td>ENCFF744SVA</td><td>TF ChIP-seq</td><td>CEBPA</td><td>ceb_ENCFF744SVA.bam</td></tr>
<tr><td>ENCFF164ALR</td><td>Histone ChIP-seq</td><td>H3K27me3</td><td>H3K27me3_ENCFF164ALR.bam</td></tr>
<tr><td>ENCFF532DQH</td><td>Histone ChIP-seq</td><td>H3K27me3</td><td>H3K27me3_ENCFF532DQH.bam</td></tr>
<tr><td>ENCFF193NPE</td><td>Histone ChIP-seq</td><td>H3K9ac</td><td>H3K9ac_ENCFF193NPE.bam</td></tr>
<tr><td>ENCFF534IPX</td><td>Histone ChIP-seq</td><td>H3K9ac</td><td>H3K9ac_ENCFF534IPX.bam</td></tr>
<tr><td>ENCFF110SOB</td><td>Control ChIP-seq</td><td>Input</td><td>Input_ENCFF110SOB.bam</td></tr>
<tr><td>ENCFF919XCV</td><td>Control ChIP-seq</td><td>Input</td><td>Input_ENCFF919XCV.bam</td></tr>
</tbody>
</table>
</div>
<hr>
<h3 id="22-simplest-and-easiet-way-to-donwload-all-the-bam-files-in-the-working-folder"><a class="header" href="#22-simplest-and-easiet-way-to-donwload-all-the-bam-files-in-the-working-folder">2.2 Simplest and easiet way to donwload all the bam files in the working folder</a></h3>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail

cat &lt;&lt;EOF | xargs -n 2 -P 4 wget -c -O
ceb_ENCFF327JFG.bam        https://www.encodeproject.org/files/ENCFF327JFG/@@download/ENCFF327JFG.bam
ceb_ENCFF744SVA.bam        https://www.encodeproject.org/files/ENCFF744SVA/@@download/ENCFF744SVA.bam
H3K27me3_ENCFF164ALR.bam   https://www.encodeproject.org/files/ENCFF164ALR/@@download/ENCFF164ALR.bam
H3K27me3_ENCFF532DQH.bam   https://www.encodeproject.org/files/ENCFF532DQH/@@download/ENCFF532DQH.bam
H3K9ac_ENCFF193NPE.bam     https://www.encodeproject.org/files/ENCFF193NPE/@@download/ENCFF193NPE.bam
H3K9ac_ENCFF534IPX.bam     https://www.encodeproject.org/files/ENCFF534IPX/@@download/ENCFF534IPX.bam
Input_ENCFF110SOB.bam      https://www.encodeproject.org/files/ENCFF110SOB/@@download/ENCFF110SOB.bam
Input_ENCFF919XCV.bam      https://www.encodeproject.org/files/ENCFF919XCV/@@download/ENCFF919XCV.bam
EOF
</code></pre>
<h2 id="3-basic-quality-checks"><a class="header" href="#3-basic-quality-checks">3. Basic Quality Checks</a></h2>
<p>Before processing, we verify the BAM files are healthy. For detailed explanations of these metrics, see <a href="#alignment-solving-the-jigsaw-puzzle">Section 05: Alignment QC</a>.</p>
<p><strong>3.1. Create a smaller test file (Optional)</strong>
Working with full genomes takes time. For testing, we can extract just chromosome 11 and 12:</p>
<pre><code class="language-bash">samtools view -b -h ceb_ENCFF327JFG.bam chr11 chr12 | samtools sort -o ceb_ENCFF327JFG.chr11_12.bam
</code></pre>
<p><strong>3.2. Get Alignment Stats</strong></p>
<p>For detailed explanation of <code>flagstat</code> output, see <a href="#understanding-bam-file-structure">Understanding BAM File Structure</a>.</p>
<pre><code class="language-bash"># Quick summary
samtools flagstat ceb_ENCFF327JFG.bam &gt; ceb_ENCFF327JFG.flagstat.txt
cat ceb_ENCFF327JFG.flagstat.txt
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">2565563 + 0 in total (QC-passed reads + QC-failed reads)
2565563 + 0 primary
0 + 0 secondary
0 + 0 supplementary
0 + 0 duplicates
0 + 0 primary duplicates
2565563 + 0 mapped (100.00% : N/A)
2565563 + 0 primary mapped (100.00% : N/A)
0 + 0 paired in sequencing
0 + 0 read1
0 + 0 read2
0 + 0 properly paired (N/A : N/A)
0 + 0 with itself and mate mapped
0 + 0 singletons (N/A : N/A)
0 + 0 with mate mapped to a different chr
0 + 0 with mate mapped to a different chr (mapQ&gt;=5)
</code></pre>
<p><strong>Verdict: 100% mapping rate - High-quality alignment, single-end data, no duplicates</strong></p>
<p><strong>3.3. Check MAPQ Distribution</strong></p>
<p>For detailed explanation of MAPQ scores and multimapping, see <a href="#multimapping--the-lost-gps">Multimapping &amp; The “Lost GPS”</a>.</p>
<pre><code class="language-bash">samtools view ceb_ENCFF327JFG.bam | awk '{print $5}' | sort -n | uniq -c
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-text">123964  30  ← Lowest score is 30 (Good confidence)
1928 31
20741 32
1477 33
4040 34
34434 35
14294 36
53329 37
30665 38
88528 39
77123 40
2960636 42  ← Highest score is 42 (Perfect confidence)
</code></pre>
<p><strong>Verdict: MAPQ ≥ 30 - File contains only uniquely mapped, high-quality reads</strong></p>
<hr>
<h2 id="directory-structure-after-bam-qc"><a class="header" href="#directory-structure-after-bam-qc">Directory Structure After BAM QC</a></h2>
<pre><code class="language-text">chipseq_tutorial/
├── encode_bam/                  ← ENCODE BAM files
│   ├── ceb_ENCFF327JFG.bam
│   ├── H3K9ac_ENCFF193NPE.bam
│   └── ...                      (8 BAM files total)
├── encode_bam_qc/               ← QC metrics for ENCODE BAMs
│   ├── ceb_ENCFF327JFG.flagstat.txt
│   ├── ceb_ENCFF327JFG.mapq.txt
│   ├── H3K9ac_ENCFF193NPE.flagstat.txt
│   ├── H3K9ac_ENCFF193NPE.mapq.txt
│   └── ...                      (16 QC files total)
└── sample_id.txt
</code></pre>
<hr>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<ol>
<li><strong>Context:</strong> We are analyzing active/repressed marks in BLaER1 cells.</li>
<li><strong>Files:</strong> BAMs are compressed alignment maps.</li>
<li><strong>QC:</strong> We use <code>samtools flagstat</code> and check <strong>MAPQ scores</strong> to ensure we aren’t analyzing “lost” multimapping reads.</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> We’ll perform cross-correlation analysis to estimate fragment length and assess signal quality.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="strand-cross-correlation-the-echo"><a class="header" href="#strand-cross-correlation-the-echo">Strand Cross-Correlation (The Echo)</a></h1>
<p><code>cross-correlation</code> <code>PhantomPeakQualTools</code> <code>fragment-length</code> <code>NSC</code> <code>RSC</code> <code>phantom-peak</code> <code>ChIP-seq</code> <code>quality-control</code> <code>run_spp.R</code> <code>ENCODE</code></p>
<h2 id="1-basic-concept-the-echo"><a class="header" href="#1-basic-concept-the-echo">1: Basic Concept (The Echo)</a></h2>
<h3 id="why-do-we-see-two-peaks"><a class="header" href="#why-do-we-see-two-peaks">Why do we see two peaks?</a></h3>
<p>When you do ChIP-seq, the DNA fragments are 3D objects, about 200bp long, with the protein in the middle.
However, the sequencer only reads the <strong>Ends</strong> of these fragments (5’ ends).</p>
<ul>
<li><strong>Forward Strand Reads:</strong> Read from the left end (Start of fragment).</li>
<li><strong>Reverse Strand Reads:</strong> Read from the right end (End of fragment).</li>
</ul>
<p>This creates two piles of reads separated by the fragment length, like two mountains with a valley in between.</p>
<h3 id="the-echo-analogy"><a class="header" href="#the-echo-analogy">The Echo Analogy</a></h3>
<p>Imagine you shout <strong>“HELLO”</strong> (Forward Reads). A split second later, you hear the echo <strong>“HELLO”</strong> (Reverse Reads).</p>
<ul>
<li><strong>Cross-Correlation</strong> is measuring exactly how long that delay is.</li>
<li>We slide the Forward reads towards the Reverse reads. When they overlap perfectly, the “volume” is loudest (Max Correlation).</li>
<li>The distance we slid them telling us the <strong>True Fragment Length</strong>.</li>
</ul>
<hr><img width="639" height="403" alt="Screenshot 2025-12-10 at 11 39 06 AM" src="https://github.com/user-attachments/assets/cfc18aa5-2c0d-4772-ad2a-f4ae8c0f578d" />
<p><em>(Source:<a href="https://www.nature.com/articles/nmeth.1246">Genome-wide analysis of transcription factor binding sites based on ChIP-Seq data</a></em></p>
<hr>
<h2 id="2-phantompeakqualtools"><a class="header" href="#2-phantompeakqualtools">2: PhantomPeakQualTools</a></h2>
<p>We use a tool called <code>run_spp.R</code> (part of <a href="https://github.com/kundajelab/phantompeakqualtools">PhantomPeakQualTools</a> ) to calculate this. It finds the “Best Match” distance.</p>
<h3 id="the-command"><a class="header" href="#the-command">The Command</a></h3>
<pre><code class="language-bash"># Run PhantomPeakQualTools
Rscript /opt/anaconda3/envs/chip/bin/run_spp.R \
      -c=sample.bam \
      -savp=Sample1_spp.qc.pdf \
      -out=Sample1_spp.qc.txt
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>-c</code>: Input BAM file.</li>
<li><code>-savp</code>: Saves the diagnostic PDF plot (The “Echo” graph).</li>
<li><code>-out</code>: Output file containing the score numbers (NSC and RSC).</li>
</ul>
<hr>
<h2 id="level-3-analysis-signal-vs-noise"><a class="header" href="#level-3-analysis-signal-vs-noise">Level 3: Analysis (Signal vs Noise)</a></h2>
<p>The output plot (<code>Sample1_spp.qc.pdf</code>) usually shows TWO peaks. This is where quality control happens.</p>
<h3 id="31-the-peaks"><a class="header" href="#31-the-peaks">3.1 The Peaks</a></h3>
<ol>
<li>
<p><strong>The Real Peak (Red Line):</strong></p>
<ul>
<li><strong>What is it?</strong> The “Echo”. The point where Forward and Reverse reads overlap because they bind the same protein.</li>
<li><strong>Location:</strong> Usually around 150-250 bp (your fragment size).</li>
<li><strong>Meaning:</strong> Represents <strong>Biological Signal</strong>.</li>
</ul>
</li>
<li>
<p><strong>The Phantom Peak (Blue Line):</strong></p>
<ul>
<li><strong>What is it?</strong> “Microphone Feedback”. It occurs at the <strong>Read Length</strong> (e.g., 50bp or 100bp).</li>
<li><strong>Why?</strong> It’s caused by mapping artifacts and “sticky” sequences. It happens in <em>every</em> experiment, even bad ones.</li>
<li><strong>Meaning:</strong> Represents <strong>Background Noise</strong>.</li>
</ul>
</li>
</ol>
<p><code>Sample1_spp.qc.txt</code> provides numeric QC metrics in colunmns from 1-11</p>
<pre><code>H3K9ac_ENCFF193NPE.chr11_12.bam   #1  BAM file name (input to SPP QC)
3411159                          #2  Number of reads used
220                              #3  Estimated fragment length (bp)
0.545418                         #4  Cross-correlation at fragment length
55                               #5  Phantom peak shift (bp)
0.501850                         #6  Cross-correlation at phantom peak
1500                             #7  Maximum strand shift tested (bp)
0.373681                         #8  Minimum cross-correlation (background)
1.459581                         #9  NSC – Normalized Strand Cross-correlation
1.339926                         #10 RSC – Relative Strand Cross-correlation
1                               #11 SPP quality tag (1 = good)
</code></pre>
<hr><img width="758" height="504" alt="Screenshot 2025-12-15 at 9 23 05 PM" src="https://github.com/user-attachments/assets/696f703d-a182-466f-aeb3-bf19a07b0272" />
<hr>
<h3 id="32-the-metrics-nsc--rsc"><a class="header" href="#32-the-metrics-nsc--rsc">3.2 The Metrics (NSC &amp; RSC)</a></h3>
<p>We compare the Height of the Real Peak (Signal) to the Phantom Peak (Noise).</p>
<p><strong>Key Metrics Table:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Metric</th><th style="text-align: left">Full Name</th><th style="text-align: left">Meaning</th><th style="text-align: left">Good Threshold</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><strong>NSC</strong></td><td style="text-align: left">Normalized Strand Cross-correlation</td><td style="text-align: left"><strong>Signal-to-Noise Ratio.</strong> How much higher is the Real Peak (COL4) than the flat background (COL8)? (COL4 / COL8)</td><td style="text-align: left"><strong>&gt; 1.05</strong></td></tr>
<tr><td style="text-align: left"><strong>RSC</strong></td><td style="text-align: left">Relative Strand Cross-correlation</td><td style="text-align: left"><strong>Signal vs Phantom.</strong> Is the Real Peak (COL4) clearly stronger than the Phantom Peak (COL6)? ((COL4 – COL8) / (COL6 – COL8))</td><td style="text-align: left"><strong>&gt; 0.8</strong></td></tr>
</tbody>
</table>
</div>
<h3 id="33-interpreting-the-data-example-analysis"><a class="header" href="#33-interpreting-the-data-example-analysis">3.3 Interpreting the Data (Example Analysis)</a></h3>
<hr><img width="943" height="470" alt="image3" src="https://github.com/user-attachments/assets/5b03189d-8fb7-4f4c-8145-5b5930921e05" />
<hr>
<ul>
<li>As shown in the plot, expectedly, the two input samples show the typical profile of unenriched DNA, with very low signal-to-noise. Their NSC values sit almost exactly at background (1.003 and 1.005), and their RSC values are only 0.62 and 0.64, which is far below what any real ChIP signal produces (NSC  &gt; 1.05 &amp; RSC &gt; 0.8)</li>
</ul>
<p>Also , <code>corelation values</code> are worth to look at :</p>
<ul>
<li><strong>Inputs (Control):</strong>
<ul>
<li>The numerically high correlation values (0.5509 and 0.5474) are driven by the dominant phantom peak, not real enrichment.</li>
</ul>
</li>
<li><strong>H3K9ac (Active Mark):</strong>
<ul>
<li>Correlation is <strong>High (0.5454 and 0.4112)</strong>.</li>
<li><strong>Interpretation:</strong> Strong signal. Acetylation marks usually give huge peaks, reflecting the broad and high-coverage nature of these marks.</li>
</ul>
</li>
<li><strong>H3K27me3 (Repressive Mark):</strong>
<ul>
<li>Correlation is <strong>Medium (0.3708 and 0.3572)</strong>.</li>
<li><strong>Interpretation:</strong> Expected. Repressive marks are broad and diffuse, so the “Echo” is quieter, fitting a repressive mark that produces wide but moderate enrichment.</li>
</ul>
</li>
<li><strong>CEBPA (Transcription Factor):</strong>
<ul>
<li>Correlation is <strong>Lower (0.2876 and 0.1979)</strong>.</li>
<li><strong>Interpretation:</strong> TF peaks are sharp but rare (small % of genome). Total signal is lower, but the peaks are distinct. This is expected because TF peaks are sharp and occupy a small fraction of the genome, so their genome-wide cross-correlation values are naturally smaller.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="directory-structure-after-cross-correlation-qc"><a class="header" href="#directory-structure-after-cross-correlation-qc">Directory Structure After Cross-Correlation QC</a></h2>
<pre><code class="language-text">chipseq_tutorial/
├── encode_bam/                  ← ENCODE BAM files
│   ├── ceb_ENCFF327JFG.bam
│   ├── H3K9ac_ENCFF193NPE.bam
│   └── ...                      (8 BAM files total)
├── encode_bam_qc/               ← QC metrics from section 08
│   ├── ceb_ENCFF327JFG.flagstat.txt
│   ├── ceb_ENCFF327JFG.mapq.txt
│   ├── H3K9ac_ENCFF193NPE.flagstat.txt
│   ├── H3K9ac_ENCFF193NPE.mapq.txt
│   └── ...                      (16 QC files total)
├── spp_qc/                      ← PhantomPeakQualTools outputs
│   ├── ceb_ENCFF327JFG_spp.qc.pdf
│   ├── ceb_ENCFF327JFG_spp.qc.txt
│   ├── H3K9ac_ENCFF193NPE_spp.qc.pdf
│   ├── H3K9ac_ENCFF193NPE_spp.qc.txt
│   └── ...                      (16 SPP files total)
└── sample_id.txt
</code></pre>
<hr>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<ol>
<li><strong>Cross-Correlation</strong> shifts reads to find the fragment length (The Echo).</li>
<li><strong>Phantom Peak</strong> is a background artifact at read length (Microphone Feedback).</li>
<li><strong>RSC &gt; 0.8</strong> means your Signal (Real Peak) is louder than your Noise (Phantom Peak).</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> We’ll perform comprehensive QC using deepTools to validate enrichment and sample consistency before peak calling.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="advanced-qc-with-deeptools-the-health-checkup"><a class="header" href="#advanced-qc-with-deeptools-the-health-checkup">Advanced QC with deepTools (The “Health Checkup”)</a></h1>
<p><code>deepTools</code> <code>plotFingerprint</code> <code>plotCoverage</code> <code>multiBamSummary</code> <code>correlation</code> <code>PCA</code> <code>ChIP-seq</code> <code>quality-control</code> <code>enrichment</code> <code>BAM-QC</code></p>
<h2 id="1-basic-concept-the-health-check"><a class="header" href="#1-basic-concept-the-health-check">1. Basic Concept (The Health Check)</a></h2>
<p>Before we call peaks, we must perform a <strong>Health Checkup</strong> on our data.</p>
<ul>
<li><strong>The Census (Fingerprint):</strong> Are the reads spread out evenly (Socialist/Input) or concentrated in specific spots (Capitalist/ChIP)?</li>
<li><strong>The Coverage Check:</strong> Do we have enough reads? Are they duplicates?</li>
<li><strong>The Family Tree (Correlation &amp; PCA):</strong> Do biological replicates (siblings) look similar? Are they distinct from the control?</li>
</ul>
<p>We use a suite of tools called <strong>deepTools</strong> to generate these reports.</p>
<hr>
<h2 id="2-running-the-qc-of-bam-files-before-peak-calling"><a class="header" href="#2-running-the-qc-of-bam-files-before-peak-calling">2. Running the QC of bam files before Peak Calling</a></h2>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p><strong>About ENCODE BAM files:</strong> The ENCODE BAM files used in this tutorial are already pre-processed (see <a href="#experiment-design--bam-quality-control">Section 08</a>). They have been deduplicated and filtered for mapping quality (MAPQ ≥ 30), meaning multimappers have been removed.</p>
</blockquote>
<p>All outputs will be saved to the <code>deeptools_qc/</code> directory for organization.</p>
<h3 id="21-fingerprint-plot"><a class="header" href="#21-fingerprint-plot">2.1 Fingerprint Plot</a></h3>
<p><strong>Requirements:</strong> BAM files in <code>encode_bam/</code> directory.</p>
<pre><code class="language-bash"># Create output directory
mkdir -p deeptools_qc

plotFingerprint \
  -b encode_bam/ceb_ENCFF327JFG.bam encode_bam/H3K9ac_ENCFF193NPE.bam encode_bam/Input_ENCFF110SOB.bam \
  --skipZeros \
  --numberOfSamples 50000 \
  -T "Fingerprints of all BAM samples" \
  --plotFile deeptools_qc/fingerprints.pdf \
  --plotFileFormat pdf \
  --dpi 600 \
  2&gt;&amp;1 | tee deeptools_qc/plotFingerprint.log
</code></pre>
<p><strong>What this does:</strong> Samples 50,000 random genomic positions and plots cumulative read distribution to assess IP enrichment. ChIP samples should show strong enrichment (steep curve), while Input should follow the diagonal.</p>
<h3 id="22-coverage-plot"><a class="header" href="#22-coverage-plot">2.2 Coverage Plot</a></h3>
<p>Checks sequencing depth and duplication levels.</p>
<pre><code class="language-bash">plotCoverage \
  -b encode_bam/ceb_ENCFF327JFG.bam encode_bam/H3K9ac_ENCFF193NPE.bam encode_bam/Input_ENCFF110SOB.bam \
  -o deeptools_qc/coverage_histogram.pdf \
  --plotFileFormat pdf \
  --dpi 600 \
  --smartLabels \
  --numberOfSamples 1000000 \
  --ignoreDuplicates \
  --minMappingQuality 30 \
  --outRawCounts deeptools_qc/coverage_counts.txt
</code></pre>
<p><strong>What this does:</strong> Samples 1 million genomic positions and plots coverage distribution. The <code>--ignoreDuplicates</code> and <code>--minMappingQuality 30</code> flags document expected data quality (ENCODE BAMs are already filtered, so these serve as safety checks).</p>
<h3 id="23-summary-matrix"><a class="header" href="#23-summary-matrix">2.3 Summary Matrix</a></h3>
<p>We need a “Count Matrix” to compare samples. This counts reads in bins across the whole genome.</p>
<pre><code class="language-bash">multiBamSummary bins \
  -b encode_bam/ceb_ENCFF327JFG.bam encode_bam/ceb_ENCFF744SVA.bam \
     encode_bam/H3K27me3_ENCFF164ALR.bam encode_bam/H3K27me3_ENCFF532DQH.bam \
     encode_bam/H3K9ac_ENCFF193NPE.bam encode_bam/H3K9ac_ENCFF534IPX.bam \  # Input BAM files (IP samples only)
  --numberOfProcessors 4 \                       # Run on 4 CPUs to speed up processing
  -o deeptools_qc/matrix.npz \                   # Output compressed matrix file (for plotting)
  --outRawCounts deeptools_qc/matrix.tab         # Output tab-separated counts file (readable text)
</code></pre>
<p><strong>What this does:</strong> Divides the genome into bins and counts reads per bin for each sample, creating a matrix used by correlation and PCA analysis. We exclude Input samples to focus on comparing ChIP enrichment patterns.</p>
<h3 id="24-correlation--pca"><a class="header" href="#24-correlation--pca">2.4 Correlation &amp; PCA</a></h3>
<p>Using the matrix from Step 2.3, we compare the samples.</p>
<p><strong>Correlation Heatmap:</strong></p>
<pre><code class="language-bash">plotCorrelation \
  -in deeptools_qc/matrix.npz \                  # Input matrix from multiBamSummary
  --corMethod spearman \                         # Use Spearman correlation (robust to outliers)
  --skipZeros \                                  # Ignore bins with zero reads
  --whatToPlot heatmap \                         # Generate a heatmap (vs scatterplot)
  --colorMap RdYlBu \                            # Color map (Red-Yellow-Blue)
  --plotNumbers \                                # Show correlation coefficients on plot
  --plotTitle "Spearman correlation of binned genome coverage" \ # Title
  --dpi 600 \                                    # High resolution for publication quality
  -o deeptools_qc/spearman_corr_plot.pdf \       # Output PDF file
  --outFileCorMatrix deeptools_qc/spearman_corr_plot.tab  # Save correlation values to text file
</code></pre>
<p><strong>What this does:</strong> Computes pairwise Spearman correlation between samples using the count matrix. Biological replicates should show high correlation, and different marks/TFs should cluster separately.</p>
<p><strong>PCA (Principal Component Analysis):</strong></p>
<pre><code class="language-bash">plotPCA \
  -in deeptools_qc/matrix.npz \                  # Input matrix from multiBamSummary
  -o deeptools_qc/pca.pdf \                      # Output PDF file
  -T "PCA of samples based on binned genome coverage" \ # Title
  --transpose \                                  # Transpose matrix (required for correct grouping)
  --plotWidth 14 \                               # Width of the plot in inches
  --plotHeight 12 \                              # Height of the plot in inches
  --plotFileFormat pdf \                         # File format
  --dpi 600 \                                    # High resolution for publication quality
  --outFileNameData deeptools_qc/pca.tab \       # Save PCA coordinates to text file
  --markers 's' 's' 'D' 'D' 'o' 'o' \            # Markers for each sample (pairs share markers)
  --colors  '#1b9e77' '#66c2a5' \                # Colors for ceb replicates (Green)
            '#d95f02' '#fc8d62' \                # Colors for H3K27me3 replicates (Orange)
            '#7570b3' '#8da0cb'                  # Colors for H3K9ac replicates (Purple)
</code></pre>
<p><strong>What this does:</strong> Reduces high-dimensional count data to 2D for visualization. Samples should cluster by biological condition, with replicates grouping together and distinct marks/TFs separating along principal components.</p>
<p><strong>Using <code>sample_id.txt</code> for dynamic BAM file lists:</strong></p>
<p><strong>Requirements:</strong> You need <code>sample_id.txt</code> file containing sample IDs (one per line, created in section 08).</p>
<pre><code class="language-bash"># Create BAM file paths from sample IDs
BAM_FILES=$(while read sample; do echo "encode_bam/${sample}.bam"; done &lt; sample_id.txt | tr '\n' ' ')

# Create labels from basenames (for cleaner plot labels)
LABELS=$(cat sample_id.txt | tr '\n' ' ')

# For IP samples only (excludes Input controls)
IP_FILES=$(grep -v "Input" sample_id.txt | while read sample; do echo "encode_bam/${sample}.bam"; done | tr '\n' ' ')
IP_LABELS=$(grep -v "Input" sample_id.txt | tr '\n' ' ')

# Echo commands to verify what we built
echo "All BAM files:"
echo $BAM_FILES
echo ""
echo "All labels:"
echo $LABELS
echo ""

</code></pre>
<p><strong>What this script does (line-by-line):</strong></p>
<p><strong>For all samples (<code>BAM_FILES</code> and <code>LABELS</code>):</strong></p>
<ol>
<li>
<p><strong><code>BAM_FILES=...</code></strong> - Reads <code>sample_id.txt</code>, loops through each sample ID, prepends <code>encode_bam/</code> and appends <code>.bam</code>, then converts newlines to spaces. Result: space-separated list of full BAM file paths.</p>
</li>
<li>
<p><strong><code>LABELS=...</code></strong> - Reads <code>sample_id.txt</code> and converts newlines to spaces. Result: space-separated list of sample IDs (basenames) for cleaner plot labels.</p>
</li>
</ol>
<p><strong>For IP samples only (<code>IP_FILES</code> and <code>IP_LABELS</code>):</strong></p>
<p>The same logic applies, but <code>grep -v "Input"</code> filters out Input control samples first, creating IP-only file and label lists for correlation/PCA analysis.</p>
<p><strong>Echo demonstrations for <code>BAM_FILES</code> and <code>LABELS</code>:</strong></p>
<pre><code class="language-bash">echo "All BAM files:"
echo $BAM_FILES
echo ""
echo "All labels:"
echo $LABELS
</code></pre>
<p><strong>Expected output:</strong></p>
<pre><code>All BAM files:

encode_bam/ceb_ENCFF327JFG.bam encode_bam/ceb_ENCFF744SVA.bam encode_bam/H3K27me3_ENCFF164ALR.bam encode_bam/H3K27me3_ENCFF532DQH.bam encode_bam/H3K9ac_ENCFF193NPE.bam encode_bam/H3K9ac_ENCFF534IPX.bam encode_bam/Input_ENCFF110SOB.bam encode_bam/Input_ENCFF919XCV.bam

All labels:
ceb_ENCFF327JFG ceb_ENCFF744SVA H3K27me3_ENCFF164ALR H3K27me3_ENCFF532DQH H3K9ac_ENCFF193NPE H3K9ac_ENCFF534IPX Input_ENCFF110SOB Input_ENCFF919XCV
</code></pre>
<p>The basenames (labels) produce cleaner plot legends compared to full file paths.</p>
<p><strong>Example usage with labels:</strong></p>
<pre><code class="language-bash"># Use with plotFingerprint
plotFingerprint -b $BAM_FILES --labels $LABELS --skipZeros ...

# Use with multiBamSummary (IP samples only)
multiBamSummary bins -b $IP_FILES --labels $IP_LABELS ...
</code></pre>
<hr>
<h2 id="level-3-reading-the-charts"><a class="header" href="#level-3-reading-the-charts">Level 3: Reading the Charts</a></h2>
<h3 id="31-interpreting-the-fingerprint-the-census"><a class="header" href="#31-interpreting-the-fingerprint-the-census"><a href="#21-fingerprint-plot">3.1 Interpreting the Fingerprint (The Census)</a></a></h3>
<p>This plot shows the cumulative read distribution across the genome. Good ChIP libraries show a clear separation between ChIP and input samples, with ChIP curves rising earlier due to enriched regions. Flat, overlapping curves usually indicate poor enrichment or over-background signal.</p>
<hr><img width="755" height="574" alt="Screenshot 2025-12-10 at 12 02 40 PM" src="https://github.com/user-attachments/assets/db1e7f33-6775-4705-b6b3-62a4c0bf7405" />
<hr>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Sample Type</th><th style="text-align: left">Interpretation</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><strong>Input</strong></td><td style="text-align: left">Close to the diagonal. Reads are uniformly distributed, behaving like ideal background.</td></tr>
<tr><td style="text-align: left"><strong>H3K9ac</strong></td><td style="text-align: left">Strong “Elbow”. Reads concentrated in a small fraction of bins (focal peaks), showing a strong bend away from the diagonal.</td></tr>
</tbody>
</table>
</div>
<h3 id="32-interpreting-coverage"><a class="header" href="#32-interpreting-coverage"><a href="#22-coverage-plot">3.2 Interpreting Coverage</a></a></h3>
<p>Next, we look at the overall coverage distribution in each BAM using plotCoverage. This reveals whether some samples are globally under-sequenced, dominated by a few high-coverage regions, or heavily affected by duplicated reads. We restrict to high-quality, non-duplicate reads to make the distributions comparable.</p>
<p><strong>Plot A: The Drop-off</strong></p>
<ul>
<li>
<p><strong>Inputs :</strong> The Input tracks sit higher at low coverage because they spread their reads across the genome without enrichment. That’s why both Input samples show a large fraction of bases at coverage 0 and 1, then taper off more slowly as coverage increases.</p>
</li>
<li>
<p><strong>ChIPs :</strong> In contrast, every IP sample collapses more sharply; the curves drop faster after coverage 1 because most genomic positions in a ChIP experiment receive almost no reads. Only a small portion of the genome — the actual binding or modification sites — reaches deeper coverage, and that fraction is tiny enough that the tail beyond coverage 2 nearly vanishes.</p>
</li>
</ul>
<hr><img width="861" height="578" alt="Screenshot 2025-12-10 at 12 03 51 PM" src="https://github.com/user-attachments/assets/26404eb5-7041-4674-bf94-d44d0d9edc8b" />
<hr>
<p><strong>Plot B: The Tail</strong>
Zooming in reveals the difference. Input covers more of the genome at 1x depth, while ChIP focuses on peaks. The Input curves decline more slowly because a larger fraction of their genome maintains at least some measurable coverage. The IP curves fall off earlier and more steeply, which reflects the enrichment pattern: most positions have essentially no reads, and only a very small subset of bases in true peak regions sustain higher coverage.</p>
<hr><img width="731" height="501" alt="Screenshot 2025-12-10 at 12 04 14 PM" src="https://github.com/user-attachments/assets/b8e24d14-d41b-4c55-a268-9982b49026c5" />
<hr>
<h3 id="33-interpreting-correlation-the-family-tree"><a class="header" href="#33-interpreting-correlation-the-family-tree"><a href="#24-correlation--pca">3.3 Interpreting Correlation (The Family Tree)</a></a></h3>
<p>Using the binned count matrix, we compute pairwise correlations between samples. A Spearman correlation heatmap shows whether biological replicates cluster together and whether inputs are distinct from ChIP samples. Poor clustering or scattered correlations usually indicate sample swaps, failed IPs, or inconsistent library prep.</p>
<p><strong>The Heatmap:</strong></p>
<ul>
<li><strong>Clustering:</strong> H3K27me3 samples cluster together and show moderately high mutual correlations (around 0.6), which is exactly what you expect for a broad repressive mark. The H3K9ac samples also correlate strongly with each other (0.76–1.0), forming a clean sub-cluster that is distinct from H3K27me3.</li>
<li><strong>Separation:</strong> Active marks (H3K9ac) should look different from Repressive marks (H3K27me3).</li>
</ul>
<hr><img width="667" height="575" alt="Screenshot 2025-12-10 at 12 05 28 PM" src="https://github.com/user-attachments/assets/652741bb-8b63-4fc2-88d8-eca5508e5938" />
<hr>
<h3 id="34-interpreting-pca"><a class="header" href="#34-interpreting-pca"><a href="#24-correlation--pca">3.4 Interpreting PCA</a></a></h3>
<p>Finally, we perform PCA on the same binned count matrix. PCA reduces the data to a few dimensions that capture most of the variance. In a good ChIP-seq dataset, biological replicates cluster together in PCA space, and distinct conditions or marks separate along major components. PCA is a convenient visual check for batch effects, sample swaps, and outlier libraries.</p>
<p><strong>The Map:</strong></p>
<ul>
<li><strong>PC1 (X-axis):</strong> The PCA shows clear separation of samples by assay type. PC1 captures most of the variance and cleanly splits the H3K27me3 group from the H3K9ac group, which is expected because these marks have very different genomic distributions.</li>
<li><strong>Clustering:</strong> The two “ceb” samples cluster tightly together, indicating consistent coverage patterns within that group. The H3K27me3 replicates are also tightly paired, which matches their broad and uniform enrichment profile. The H3K9ac replicates sit on the opposite side of PC1, with one replicate shifted slightly on PC2, hinting at a mild difference in coverage distribution but nothing severe. If one replicate is far away, it might be an outlier/bad sample.</li>
</ul>
<hr><img width="983" height="488" alt="Screenshot 2025-12-10 at 12 05 56 PM" src="https://github.com/user-attachments/assets/d2d785d1-4da3-4cc4-a3e0-1ee612ad3d38" />
<hr>
<h2 id="directory-structure-after-deeptools-qc"><a class="header" href="#directory-structure-after-deeptools-qc">Directory Structure After deepTools QC</a></h2>
<pre><code class="language-text">chipseq_tutorial/
├── encode_bam/                  ← ENCODE BAM files
│   ├── ceb_ENCFF327JFG.bam
│   ├── H3K9ac_ENCFF193NPE.bam
│   └── ...                      (8 BAM files total)
├── encode_bam_qc/               ← QC from section 08
│   └── ...
├── spp_qc/                      ← QC from section 09
│   └── ...
├── deeptools_qc/                ← deepTools outputs
│   ├── fingerprints.pdf
│   ├── plotFingerprint.log
│   ├── coverage_histogram.pdf
│   ├── coverage_counts.txt
│   ├── matrix.npz
│   ├── matrix.tab
│   ├── spearman_corr_plot.pdf
│   ├── spearman_corr_plot.tab
│   ├── pca.pdf
│   └── pca.tab
└── sample_id.txt
</code></pre>
<hr>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<ol>
<li><strong>Fingerprint:</strong> Confirms your IP worked (Sharp elbow).</li>
<li><strong>Coverage:</strong> Confirms sequencing depth (Inputs = broad, ChIP = peaky).</li>
<li><strong>PCA/Correlation:</strong> Confirms your replicates match (Siblings cluster together).</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> With comprehensive QC validation complete, we’re ready to call peaks with MACS2 and identify protein-DNA bindin sites.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="peak-calling-with-macs3-the-summit-search"><a class="header" href="#peak-calling-with-macs3-the-summit-search">Peak Calling with MACS3 (The Summit Search)</a></h1>
<p><code>MACS3</code> <code>peak-calling</code> <code>ChIP-seq</code> <code>narrow-peaks</code> <code>broad-peaks</code> <code>p-value</code> <code>transcription-factors</code></p>
<h2 id="1-basic-concept-the-heap-hunt"><a class="header" href="#1-basic-concept-the-heap-hunt">1. Basic Concept (The “Heap” Hunt)</a></h2>
<h3 id="what-is-a-peak"><a class="header" href="#what-is-a-peak">What is a Peak?</a></h3>
<p>Imagine you are looking for hidden treasure on a long beach (the Genome).</p>
<ul>
<li><strong>Random Reads:</strong> Sand scattered everywhere evenly (Background noise).</li>
<li><strong>A “Peak”:</strong> A huge heap of sand in one specific spot.</li>
</ul>
<p>This heap means thousands of protein molecules were bound to that exact spot of DNA.</p>
<h3 id="signal-vs-noise"><a class="header" href="#signal-vs-noise">Signal vs. Noise</a></h3>
<ul>
<li><strong>Signal:</strong> The Heap (Peak).</li>
<li><strong>Noise:</strong> The random thin layer of sand everywhere else (Input/Control).</li>
</ul>
<p><strong>MACS3</strong> is the software that scans the beach, measures the height of the sand pile, and calculates if it is “significantly” higher than the background.</p>
<h3 id="narrow-vs-broad-peaks"><a class="header" href="#narrow-vs-broad-peaks">Narrow vs. Broad Peaks</a></h3>
<p>Different histone modifications and chromatin marks create distinct peak shapes based on their biological function:</p>
<img width="661" height="371" alt="Screenshot 2025-12-21 at 12 36 14 PM" src="https://github.com/user-attachments/assets/ea7d96e9-d8eb-4e4c-822c-0e7efe82821f" />
<hr>
<h2 id="2-requirements"><a class="header" href="#2-requirements">2. Requirements</a></h2>
<h3 id="input-files"><a class="header" href="#input-files">Input Files</a></h3>
<p>You need the following files in your workspace:</p>
<p><strong>BAM files:</strong> Located in <code>encode_bam/</code> directory</p>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p><strong>ENCODE Pre-processing:</strong> These BAM files from ENCODE are already deduplicated and filtered for mapping quality (MAPQ ≥ 30). This is documented in <a href="#advanced-qc-with-deeptools-the-health-checkup">Tutorial 10</a>. You do NOT need to run additional filtering.</p>
</blockquote>
<hr>
<h2 id="3-execution-step-by-step"><a class="header" href="#3-execution-step-by-step">3. Execution (Step-by-Step)</a></h2>
<p>We call peaks on <strong>each replicate individually</strong>, then assess reproducibility using IDR (Irreproducible Discovery Rate). This is the <a href="https://www.encodeproject.org/chip-seq/transcription_factor/">ENCODE standard workflow</a>.</p>
<h3 id="step-1-create-output-directory"><a class="header" href="#step-1-create-output-directory">Step 1: Create Output Directory</a></h3>
<pre><code class="language-bash">mkdir -p macs3_results
</code></pre>
<h3 id="step-2-h3k9ac-narrow-peaks---both-replicates"><a class="header" href="#step-2-h3k9ac-narrow-peaks---both-replicates">Step 2: H3K9ac (Narrow Peaks) - Both Replicates</a></h3>
<p>H3K9ac (Acetylation) creates sharp, tall spikes at active promoters and enhancers.</p>
<p><strong>Replicate 1:</strong></p>
<pre><code class="language-bash">macs3 callpeak \
  -t encode_bam/H3K9ac_ENCFF534IPX.bam \
  -c encode_bam/Input_ENCFF110SOB.bam \
  -f BAM \
  -g hs \
  -n H3K9ac_ENCFF534IPX \
  -p 0.01 \
  --keep-dup all \
  --outdir macs3_results
</code></pre>
<p><strong>Replicate 2:</strong></p>
<pre><code class="language-bash">macs3 callpeak \
  -t encode_bam/H3K9ac_ENCFF193NPE.bam \
  -c encode_bam/Input_ENCFF919XCV.bam \
  -f BAM \
  -g hs \
  -n H3K9ac_ENCFF193NPE \
  -p 0.01 \
  --keep-dup all \
  --outdir macs3_results
</code></pre>
<h3 id="expected-outputs"><a class="header" href="#expected-outputs">Expected Outputs</a></h3>
<p>After running MACS3, you will have:</p>
<pre><code class="language-bash">macs3_results/
├── H3K9ac_ENCFF534IPX_peaks.narrowPeak
├── H3K9ac_ENCFF534IPX_peaks.xls
├── ... (similar files for all 6 replicates)
└── H3K9ac_idr_peaks.txt        # After IDR analysis
</code></pre>
<p><strong>Parameter Explanation:</strong></p>
<ul>
<li><code>-t</code>: Treatment file (IP sample - the enriched DNA).</li>
<li><code>-c</code>: Control file (Input - background DNA).</li>
<li><code>-f BAM</code>: Input file format.</li>
<li><code>-g hs</code>: Genome size (<code>hs</code> = human ~2.7Gb, can also use numeric <code>2.7e9</code> or <code>2.9e9</code> for hg38).</li>
<li><code>-n</code>: Output file prefix (use the ENCODE accession for clarity).</li>
<li><code>-p 0.01</code>: P-value cutoff. Keep only peaks with p-value &lt; 0.01 (1% significance threshold).
<ul>
<li><strong>Why <code>-p</code> instead of <code>-q</code>?</strong> We use IDR (Irreproducible Discovery Rate)  to filter for reproducible peaks between replicates. Starting with lenient <code>-p</code> thresholds captures more candidate peaks, then IDR applies stringent reproducibility filtering. This “liberal discovery + stringent validation” approach is standard for replicated ChIP-seq.</li>
</ul>
</li>
<li><code>--keep-dup all</code>: For deduplicated BAM files (duplicates already removed). Use <code>--keep-dup 1</code> if BAMs still contain duplicates.</li>
<li><code>--outdir</code>: Output directory.</li>
</ul>
<p><strong>Optional Parameters:</strong></p>
<ul>
<li>
<p><code>-B</code> or <code>--bdg</code>: Generate bedGraph files for fragment pileup and control lambda.</p>
</li>
<li>
<p><code>--bdg --SPMR</code>: Combine with <code>-B</code> to normalize bedGraph by signal per million reads (SPMR)</p>
</li>
<li>
<p><code>-f BAMPE</code>: Explicitly specify paired-end BAM format (BAMPE = BAM with PE alignment)</p>
</li>
<li>
<p><code>--nomodel --extsize &lt;size&gt;</code>: Override automatic fragment size estimation (only needed if model building fails)</p>
</li>
</ul>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Summit positions for motif analysis:</strong> This tutorial does not use <code>--call-summits</code> in MACS3 because precise summit positions will be extracted during IDR analysis , where we identify reproducible peaks and derive consensus summits for motif discovery.</p>
</blockquote>
<h3 id="step-3-h3k27me3-broad-peaks---both-replicates"><a class="header" href="#step-3-h3k27me3-broad-peaks---both-replicates">Step 3: H3K27me3 (Broad Peaks) - Both Replicates</a></h3>
<p>H3K27me3 (Trimethylation) creates wide, gentle hills marking repressed chromatin domains.</p>
<p><strong>Replicate 1:</strong></p>
<pre><code class="language-bash">macs3 callpeak \
  -t encode_bam/H3K27me3_ENCFF532DQH.bam \
  -c encode_bam/Input_ENCFF110SOB.bam \
  -f BAM \
  -g hs \
  -n H3K27me3_ENCFF532DQH \
  --broad -p 0.01\
  --keep-dup all \
  --outdir macs3_results
</code></pre>
<p><strong>Replicate 2:</strong></p>
<pre><code class="language-bash">macs3 callpeak \
  -t encode_bam/H3K27me3_ENCFF164ALR.bam \
  -c encode_bam/Input_ENCFF919XCV.bam \
  -f BAM \
  -g hs \
  -n H3K27me3_ENCFF164ALR \
   --broad -p 0.01\
  --keep-dup all \
  --outdir macs3_results
</code></pre>
<h3 id="step-4-cebpa-narrow-peaks---transcription-factor---both-replicates"><a class="header" href="#step-4-cebpa-narrow-peaks---transcription-factor---both-replicates">Step 4: CEBPA (Narrow Peaks - Transcription Factor) - Both Replicates</a></h3>
<p>Transcription factors like CEBPA bind to very specific DNA sequences, creating extremely sharp peaks.</p>
<p><strong>Replicate 1:</strong></p>
<pre><code class="language-bash">macs3 callpeak \
  -t encode_bam/ceb_ENCFF327JFG.bam \
  -c encode_bam/Input_ENCFF110SOB.bam \
  -f BAM \
  -g hs \
  -n ceb_ENCFF327JFG \
  -p 0.01 \
  --keep-dup all \
  --outdir macs3_results
</code></pre>
<p><strong>Replicate 2:</strong></p>
<pre><code class="language-bash">macs3 callpeak \
  -t encode_bam/ceb_ENCFF744SVA.bam \
  -c encode_bam/Input_ENCFF919XCV.bam \
  -f BAM \
  -g hs \
  -n ceb_ENCFF744SVA \
  -p 0.01 \
  --keep-dup all \
  --outdir macs3_results
</code></pre>
<hr>
<h2 id="4-understanding-the-outputs"><a class="header" href="#4-understanding-the-outputs">4. Understanding the Outputs</a></h2>
<p>After running the commands, inspect <code>macs3_results/</code>. For each sample, you’ll see:</p>
<h3 id="file-types"><a class="header" href="#file-types">File Types</a></h3>
<h4 id="1-_peaksnarrowpeak-or-_peaksbroadpeak--bed6--4-10-cols-narrow-and-bed6--3-9-cols-broad"><a class="header" href="#1-_peaksnarrowpeak-or-_peaksbroadpeak--bed6--4-10-cols-narrow-and-bed6--3-9-cols-broad">1. <code>*_peaks.narrowPeak</code> (or <code>*_peaks.broadPeak</code>)  [BED6 + 4 (10 cols) narrow and BED6 + 3 (9 cols) broad]</a></h4>
<ul>
<li><strong>What is it?</strong> The final list of called peaks.</li>
<li><strong>Format:</strong> BED-like format with 10 columns:
<ul>
<li>Columns 1-3: Chromosome, start, end</li>
<li>Column 4: Peak name</li>
<li>Column 5: Integer score (for display)</li>
<li>Column 6: Strand (always <code>.</code> for ChIP-seq)</li>
<li>Column 7: Fold enrichment</li>
<li>Column 8: -log10(p-value)</li>
<li>Column 9: -log10(q-value)</li>
<li>Column 10: Summit position (relative to start)</li>
</ul>
</li>
<li><strong>Use:</strong> Open in IGV or use for downstream analysis (annotation, motif finding).</li>
</ul>
<p><strong>View the file:</strong></p>
<pre><code class="language-text">rajaishaqnabikhan@Rajas-MacBook-Pro bws % head -4 macs3_results/H3K9ac_ENCFF193NPE_peaks.narrowPeak

chr1 777980 778754 H3K9ac_ENCFF193NPE_peak_1a 67 . 3.55173 8.65761 6.72906 109
chr1 777980 778754 H3K9ac_ENCFF193NPE_peak_1b 473 . 9.73436 49.6911 47.3476 508
chr1 778874 779368 H3K9ac_ENCFF193NPE_peak_2 254 . 7.6257 27.596 25.4103 313
chr1 826684 827604 H3K9ac_ENCFF193NPE_peak_3 975 . 18.662 100.173 97.5777 717

</code></pre>
<p><strong>Interpreting the columns:</strong></p>
<ul>
<li>Peak <code>H3K9ac_ENCFF193NPE_peak_3</code> has the highest score (975) and fold enrichment (18.7x)</li>
<li>Column 10 (e.g., 717 for peak_3) is the summit offset: summit is at position 826684+717 = 827401</li>
</ul>
<h4 id="3-_peaksxls"><a class="header" href="#3-_peaksxls">3. <code>*_peaks.xls</code></a></h4>
<ul>
<li><strong>What is it?</strong> Excel-friendly table with detailed peak statistics.</li>
<li><strong>Contents:</strong> All peak coordinates plus:
<ul>
<li><code>fold_enrichment</code>: How many times higher than background (e.g., 10.5 = 10.5x enrichment)</li>
<li><code>-log10(pvalue)</code>: Statistical significance (higher = more significant)</li>
<li><code>-log10(qvalue)</code>: FDR-corrected p-value (accounts for multiple testing)</li>
</ul>
</li>
<li><strong>Use:</strong> Filter peaks, rank by significance, extract statistics for publication.</li>
</ul>
<p><strong>Example interpretation:</strong></p>
<pre><code class="language-text">Peak with fold_enrichment=15.3, -log10(qvalue)=50.2
→ Signal is 15.3x higher than background
→ q-value = 10^-50.2 ≈ 6.3e-51 (extremely significant!)
</code></pre>
<h4 id="4-_modelr-narrow-peaks-only"><a class="header" href="#4-_modelr-narrow-peaks-only">4. <code>*_model.r</code> (narrow peaks only)</a></h4>
<ul>
<li>
<p><strong>What is it?</strong> R script that generates a PDF showing the shift model.</p>
</li>
<li>
<p><strong>Use:</strong> QC visualization showing fragment length estimation.</p>
</li>
<li>
<p><strong>How to use:</strong></p>
<pre><code class="language-bash">Rscript macs3_results/H3K9ac_ENCFF534IPX_model.r &gt;  macs3_results/H3K9ac_ENCFF534IPX_mode.pdf
</code></pre>
</li>
</ul>
<hr>
<h2 id="directory-structure-after-peak-calling"><a class="header" href="#directory-structure-after-peak-calling">Directory Structure After Peak Calling</a></h2>
<pre><code class="language-text">chipseq_tutorial/
├── encode_bam/                  ← ENCODE BAM files (input)
│   ├── H3K9ac_ENCFF534IPX.bam
│   ├── H3K27me3_ENCFF532DQH.bam
│   ├── ceb_ENCFF327JFG.bam
│   └── ...                      (
├── deeptools_qc/                ← QC from deeptools
│   ├── fingerprints.pdf
│   ├── coverage_histogram.pdf
│   └── ...
└── macs3_results/               ← MACS3 outputs
    ├── H3K9ac_ENCFF534IPX_peaks.narrowPeak
    ├── H3K9ac_ENCFF534IPX_peaks.xls
    ├── H3K9ac_ENCFF534IPX_summits.bed
    ├── H3K9ac_ENCFF534IPX_model.r
    ├── H3K27me3_ENCFF532DQH_peaks.broadPeak
    ├── H3K27me3_ENCFF532DQH_peaks.xls
    ├── ceb_ENCFF327JFG_peaks.narrowPeak
    ├── ceb_ENCFF327JFG_peaks.xls
    └── ...                       
</code></pre>
<hr>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p>You have successfully called peaks using MACS3 for:</p>
<ol>
<li><strong>H3K9ac</strong> (narrow peaks, active histone mark)</li>
<li><strong>H3K27me3</strong> (broad peaks, repressive mark)</li>
<li><strong>CEBPA</strong> (narrow peaks, transcription factor)</li>
</ol>
<p><strong>Peak calling strategy:</strong></p>
<ul>
<li>Used <code>-p 0.01</code> for lenient discovery (captures candidate peaks)</li>
<li>Will apply IDR filtering in Tutorial 13 for stringent validation</li>
<li>No <code>--call-summits</code> here - summits extracted during IDR analysis</li>
</ul>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> Calculate FRiP (Fraction of Reads in Peaks) quality metrics to validate peak enrichment, then assess reproducibility with IDR and perform motif discovery.</p>
</blockquote>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="quality-metrics---frip-fraction-of-reads-in-peaks"><a class="header" href="#quality-metrics---frip-fraction-of-reads-in-peaks">Quality Metrics - FRiP (Fraction of Reads in Peaks)</a></h1>
<p><code>FRiP</code> <code>quality-control</code> <code>ChIP-seq</code> <code>ENCODE-standards</code> <code>peak-calling</code> <code>QC-metrics</code></p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Having called peaks with MACS3, we now quantify ChIP enrichment quality using <strong>FRiP</strong> (Fraction of Reads in Peaks). FRiP measures the proportion of sequencing reads that overlap called peak regions versus background.</p>
<p>In successful ChIP-seq experiments, immunoprecipitation selectively enriches DNA fragments bound by the target protein, causing a substantial fraction of reads to concentrate in peak regions. The remainder represents genomic background from non-specific binding or incomplete washing. By contrast, failed experiments show most reads distributed evenly across the genome, yielding low FRiP values.</p>
<p>FRiP thus provides a rapid, quantitative metric for immunoprecipitation efficiency—high FRiP indicates successful enrichment, while low FRiP flags potential technical problems before investing effort in downstream analysis.</p>
<hr>
<h2 id="1-what-is-frip"><a class="header" href="#1-what-is-frip">1. What is FRiP?</a></h2>
<p>FRiP measures how much of your ChIP signal is concentrated in called peaks. It’s a key ENCODE quality metric.</p>
<h3 id="calculating-frip"><a class="header" href="#calculating-frip">Calculating FRiP</a></h3>
<p><strong>Formula:</strong> FRiP = (Reads in peaks) / (Total mapped reads)</p>
<p><strong>Input files:</strong></p>
<ul>
<li>BAM file: <code>encode_bam/ceb_ENCFF327JFG.bam</code> (deduplicated, MAPQ filtered)</li>
<li>Peak file: <code>macs3_results/ceb_ENCFF327JFG_peaks.narrowPeak</code></li>
</ul>
<p><strong>Complete FRiP calculation script:</strong></p>
<pre><code class="language-bash"># Step 1: Count total mapped reads
TOTAL_READS=$(samtools view -c encode_bam/ceb_ENCFF327JFG.bam)
</code></pre>
<p>This command counts the total number of alignments in the BAM file. Since the BAM is already deduplicated and MAPQ-filtered, this value represents the total number of mapped reads, which serves as the denominator in the FRiP calculation.</p>
<pre><code class="language-bash"># Step 2: Merge overlapping peak regions (avoid double-counting)
mkdir -p frip_analysis
sort -k1,1 -k2,2n macs3_results/ceb_ENCFF327JFG_peaks.narrowPeak | \
  bedtools merge -i stdin &gt; frip_analysis/ceb_ENCFF327JFG.peaks.merged.bed
</code></pre>
<p>MACS3 peak files may contain overlapping or adjacent peak regions. To avoid double-counting reads that overlap multiple nearby peaks, all peak intervals are first sorted and then merged into a non-redundant set of regions. This step ensures that each read contributes at most once to the FRiP numerator.</p>
<pre><code class="language-bash"># Step 3: Count reads overlapping peaks (unique reads only)
READS_IN_PEAKS=$(
  samtools view -b encode_bam/ceb_ENCFF327JFG.bam | \
  bedtools intersect -u -a stdin -b frip_analysis/ceb_ENCFF327JFG.peaks.merged.bed | \
  samtools view -c
)
</code></pre>
<p>Aligned reads from the BAM file are intersected with the merged peak regions. The <code>-u</code> option ensures that each read is counted only once, even if it overlaps more than one peak interval. The resulting count corresponds to the number of unique reads that fall within CEBPA peak regions.</p>
<pre><code class="language-bash"># Step 4: Calculate the FRiP score
FRIP=$(awk -v n="${READS_IN_PEAKS}" -v d="${TOTAL_READS}" \
  'BEGIN {printf "%.5f", n/d}')
</code></pre>
<p>The FRiP score is calculated as the ratio of reads overlapping peak regions to the total number of mapped reads. The result is formatted to five decimal places for clarity and consistency.</p>
<h3 id="complete-frip-calculation-script"><a class="header" href="#complete-frip-calculation-script">Complete FRiP Calculation Script</a></h3>
<p>For convenience, here’s the complete executable script combining all steps:</p>
<pre><code class="language-bash">#!/bin/bash
# Complete FRiP calculation for ceb_ENCFF327JFG
mkdir -p frip_analysis

# Count total reads
TOTAL_READS=$(samtools view -c encode_bam/ceb_ENCFF327JFG.bam)

# Merge overlapping peaks
sort -k1,1 -k2,2n macs3_results/ceb_ENCFF327JFG_peaks.narrowPeak | \
  bedtools merge -i stdin &gt; frip_analysis/ceb_ENCFF327JFG.peaks.merged.bed

# Count reads in peaks
READS_IN_PEAKS=$(samtools view -b encode_bam/ceb_ENCFF327JFG.bam | \
  bedtools intersect -u -a stdin -b frip_analysis/ceb_ENCFF327JFG.peaks.merged.bed | \
  samtools view -c)

# Calculate FRiP
FRIP=$(awk -v n="${READS_IN_PEAKS}" -v d="${TOTAL_READS}" 'BEGIN {printf "%.5f", n/d}')

# Report results
echo "Sample: ceb_ENCFF327JFG"
echo "Total mapped reads : ${TOTAL_READS}"
echo "Reads in peaks     : ${READS_IN_PEAKS}"
echo "FRiP               : ${FRIP}"
</code></pre>
<hr>
<h3 id="expected-output"><a class="header" href="#expected-output">Expected Output</a></h3>
<p><strong>Results we got:</strong></p>
<pre><code class="language-text">sample total_reads reads_in_peaks FRiP
ceb_ENCFF327JFG 27863042 1511077 0.05423
ceb_ENCFF744SVA 16814770 1187486 0.07062
H3K27me3_ENCFF164ALR 39952273 11528033 0.28855
H3K27me3_ENCFF532DQH 35184227 10987930 0.31230
H3K9ac_ENCFF193NPE 34567738 14283991 0.41322
H3K9ac_ENCFF534IPX 39792428 6625200 0.16649

</code></pre>
<h3 id="interpreting-these-results"><a class="header" href="#interpreting-these-results">Interpreting These Results</a></h3>
<p><strong>Key Observations:</strong></p>
<ul>
<li><strong>H3K9ac:</strong> Replicate discordance (41% vs 17%) needs IDR validation</li>
<li><strong>H3K27me3:</strong> Excellent concordance (~30%) indicates robust data</li>
<li><strong>CEBPA:</strong> Low (5-7%) but acceptable for sparse transcription factors</li>
</ul>
<hr>
<h3 id="frip-quality-standards"><a class="header" href="#frip-quality-standards">FRiP Quality Standards</a></h3>
<p>ENCODE guidelines (<a href="https://doi.org/10.1101/gr.136184.111">Landt et al. 2012</a>) flag transcription factor experiments with FRiP below ~1%, as such values often reflect weak enrichment or technical failure, while well-defined point-source factors like CTCF or REST frequently achieve FRiP values of 20–50%. These expectations are not universal: factors with few binding sites or low occupancy can yield FRiP &lt;1% yet remain biologically valid.</p>
<p>Histone marks generally show higher FRiP due to their broader genomic coverage, though acceptable values differ markedly between narrow and broad marks.</p>
<p>Because FRiP depends strongly on sequencing depth, peak-calling parameters, and the biological target, it should always be interpreted in conjunction with complementary QC metrics such as fingerprint plots, strand cross-correlation, and coverage profiles, not in isolation.</p>
<hr>
<h2 id="directory-structure-after-frip-calculation"><a class="header" href="#directory-structure-after-frip-calculation">Directory Structure After FRiP Calculation</a></h2>
<pre><code class="language-text">chipseq_tutorial/
├── encode_bam/                  ← Input BAM files
│   ├── ceb_ENCFF327JFG.bam
│   └── ...
├── macs3_results/               ← Peak files from MACS3
│   ├── ceb_ENCFF327JFG_peaks.narrowPeak
│   ├── H3K9ac_ENCFF534IPX_peaks.narrowPeak
│   └── ...
└── frip_analysis/               ← FRiP working files (optional)
    ├── ceb_ENCFF327JFG.peaks.merged.bed
    └── frip_scores.txt
</code></pre>
<hr>
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<p>You’ve learned how to:</p>
<ul>
<li>Calculate FRiP (Fraction of Reads in Peaks) quality metrics</li>
<li>Interpret FRiP values according to ENCODE guidelines</li>
<li>Understand what constitutes good vs. poor ChIP-seq data</li>
</ul>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> Assess reproducibility between replicates using IDR (Irreproducible Discovery Rate) and identify consensus peaks for downstream motif analysis.</p>
</blockquote>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="reproducibility-analysis---idr-consensus-peaks--motif-discovery"><a class="header" href="#reproducibility-analysis---idr-consensus-peaks--motif-discovery">Reproducibility Analysis - IDR, Consensus Peaks &amp; Motif Discovery</a></h1>
<p><code>IDR</code> <code>reproducibility</code> <code>consensus-peaks</code> <code>motif-analysis</code> <code>HOMER</code> <code>MEME-ChIP</code> <code>ENCODE</code> <code>peak-filtering</code></p>
<hr>
<h2 id="1-reproducibility-analysis-idr-irreproducible-discovery-rate"><a class="header" href="#1-reproducibility-analysis-idr-irreproducible-discovery-rate">1. Reproducibility Analysis: IDR (Irreproducible Discovery Rate)</a></h2>
<p><strong>IDR</strong> (<a href="https://github.com/nboley/idr#output-file-format">https://github.com/nboley/idr#output-file-format</a>) is a statistical framework used to quantify how consistently peaks are detected between biological replicates. It was developed for large-scale functional genomics projects and is mandated by <strong>ENCODE</strong> for ChIP-seq reproducibility assessment.</p>
<p>IDR models peak rankings between replicates and estimates the probability that a peak is irreproducible noise rather than a real signal.</p>
<h3 id="why-idr-matters"><a class="header" href="#why-idr-matters">Why IDR Matters</a></h3>
<ul>
<li>Peaks unique to one replicate are likely noise</li>
<li>Peaks present in both replicates are high-confidence</li>
<li>IDR &lt; 0.05 means peaks are reproducible</li>
</ul>
<p>ENCODE describes <a href="https://www.encodeproject.org/data-standards/terms/">two ways</a> to define reproducible peaks using IDR. The conservative approach, used here, runs IDR on true biological replicates and keeps only peaks that agree between independent experiments, giving high-confidence results. The optimal approach runs IDR on pseudoreplicates created by randomly splitting pooled data, which increases sensitivity. In this tutorial, we use the conservative approach with the biological replicates ceb_ENCFF327JFG_peaks and ceb_ENCFF744SVA_peaks.narrowPeak to focus on reproducible peaks.</p>
<h3 id="installing-idr"><a class="header" href="#installing-idr">Installing IDR</a></h3>
<p><strong>Install IDR</strong> (if not already installed):</p>
<p>IDR has <strong>binary and dependency issues on macOS ARM64</strong>, and it is recommended to create a <strong>dedicated environment</strong> to avoid conflicts with other packages.</p>
<pre><code>name: idr_env
channels:
  - conda-forge
  - bioconda
dependencies:
  - python=3.9
  - numpy=1.23.5
  - scipy=1.10.1
  - matplotlib=3.7.1
  - pip
  - pip:
      - git+https://github.com/nboley/idr.git

</code></pre>
<pre><code class="language-bash">conda env create -f idr_env.yml
conda activate idr_env
</code></pre>
<hr>
<h2 id="2-running-idr-on-cebpa-replicates"><a class="header" href="#2-running-idr-on-cebpa-replicates">2. Running IDR on CEBPA Replicates</a></h2>
<pre><code class="language-bash">idr --samples \
  macs3_results/ceb_ENCFF327JFG_peaks.narrowPeak \
  macs3_results/ceb_ENCFF744SVA_peaks.narrowPeak \
  --input-file-type narrowPeak \
  --rank signal.value \
  --output-file idr/ceb_idr_peaks.txt \
  --plot \
  --log-output-file idr/ceb_idr.log
</code></pre>
<p><strong>Parameter Explanation:</strong></p>
<ul>
<li><code>--samples</code>: The two replicate peak files</li>
<li><code>--rank p.value</code>: Rank peaks by p-value (ENCODE default)</li>
<li>Alternatives: <code>signal.value</code> (fold enrichment) or <code>q.value</code> (FDR)</li>
<li><code>--plot</code>: Generate diagnostic plots showing replicate concordance</li>
<li><code>--log-output-file</code>: Save detailed statistics</li>
</ul>
<h3 id="interpreting-idr-output"><a class="header" href="#interpreting-idr-output">Interpreting IDR Output</a></h3>
<p>The output file <code>ceb_idr_peaks.txt</code> contains peaks found in both replicates with IDR scores. See the <a href="https://github.com/nboley/idr">official IDR documentation</a> for complete format details.</p>
<p><strong>Key Columns:</strong></p>
<p><strong>Columns 1-3 (chr, start, end):</strong> Genomic coordinates of the merged peak region where reproducible signal was detected.</p>
<p><strong>Column 5 (scaled IDR score):</strong> Compressed 0-1000 score for ranking and visualization only (NOT for filtering). Higher values indicate better reproducibility:</p>
<ul>
<li>IDR = 0 → score = 1000 (perfect)</li>
<li>IDR = 0.05 → score ≈ 540</li>
</ul>
<p><strong>Column 7 (signalValue):</strong> Strength of ChIP enrichment inherited from MACS3. Reflects signal intensity, not reproducibility.</p>
<p><strong>Column 11 (local IDR):</strong> Reproducibility score for this specific peak using <code>-log10(IDR)</code> scale.</p>
<p><strong>Column 12 (global IDR):</strong> <strong>Primary ENCODE metric</strong> for defining reproducible peaks across replicates, also on <code>-log10(IDR)</code> scale where higher values = better reproducibility:</p>
<ul>
<li><code>-log10(IDR) ≥ 1.3</code> → IDR ≤ 0.05 (standard threshold)</li>
<li><code>-log10(IDR) ≥ 2.0</code> → IDR ≤ 0.01 (very stringent)</li>
<li>Formula: <code>-log10(0.05) = 1.301 ≈ 1.3</code></li>
</ul>
<p><strong>Check peak counts at different thresholds:</strong></p>
<pre><code class="language-bash"># Standard threshold (IDR ≤ 0.05)
awk '$12 &gt;= 1.3' idr/ceb_idr_peaks.txt | wc -l

# Stringent threshold (IDR ≤ 0.01)
awk '$12 &gt;= 2.0' idr/ceb_idr_peaks.txt | wc -l
</code></pre>
<hr>
<h3 id="filtering-for-reproducible-peaks"><a class="header" href="#filtering-for-reproducible-peaks">Filtering for Reproducible Peaks</a></h3>
<p>Filter peaks that pass the standard IDR threshold:</p>
<pre><code class="language-bash">awk '$12 &gt;= 1.3' idr/ceb_idr_peaks.txt &gt; idr/ceb_idr_passed.bed
</code></pre>
<pre><code># Count results

(chip) rajaishaqnabikhan@Rajas-MacBook-Pro bws % wc -l &lt;  idr/ceb_idr_peaks.txt
    32273
(chip) rajaishaqnabikhan@Rajas-MacBook-Pro bws % wc -l &lt;  idr/ceb_idr_passed.bed
     9468

</code></pre>
<p><strong>Interpretation:</strong></p>
<p>Roughly 29.3% (9,468/32,273) of initial peaks are reproducible at IDR ≤ 0.05. This is entirely reasonable for a transcription factor ChIP-seq, where we expect only the strongest, most reproducible binding sites to pass stringent filtering.</p>
<hr>
<h3 id="understanding-idr-diagnostic-plots"><a class="header" href="#understanding-idr-diagnostic-plots">Understanding IDR Diagnostic Plots</a></h3>
<p>IDR generates three diagnostic plots to visualize replicate concordance:</p>
<p><strong>Plot 1: Rank Consistency Plot</strong></p>
<img width="232" height="235" alt="image" src="https://github.com/user-attachments/assets/90e32a53-16c6-423e-b42f-af30f9f7ba7e" />
<p>This plot displays the normalized rank of peaks in replicate 1 (X-axis) versus replicate 2 (Y-axis). Each point represents a peak shared between replicates, with black/gray points indicating reproducible peaks (IDR &lt; 0.05) and red points showing irreproducible peaks (IDR ≥ 0.05). A strong diagonal indicates good replicate concordance, where high-ranking peaks in one replicate are also high-ranking in the other.</p>
<p><strong>Plot 2: Signal Consistency Plot</strong></p>
<img width="276" height="249" alt="image" src="https://github.com/user-attachments/assets/26f276dc-2525-4775-b155-4ef31b4d01ae" />
<p>This log10(signal)-log10(signal) plot compares signal strength between replicates, with black points representing reproducible peaks (IDR &lt; 0.05) and red points showing irreproducible peaks (IDR ≥ 0.05). A tight diagonal band for black points confirms that strong peaks are consistently strong in both replicates, validating the biological signal.</p>
<p><strong>Plot 3: IDR vs Peak Rank</strong></p>
<img width="237" height="237" alt="image" src="https://github.com/user-attachments/assets/21224773-01fd-4d61-8b91-fb92ae71f0f5" />
<p>This plot shows peak rank bins for replicate 1 (X-axis, with best peaks on the right) versus -log10(IDR) scores (Y-axis). Individual points represent peaks, with boxplots summarizing IDR distributions within rank bins. The dashed horizontal line marks the IDR = 0.05 cutoff (-log10 ≈ 1.3). A sigmoidal curve where -log10(IDR) increases sharply as peak rank improves indicates that top-ranked peaks have high reproducibility scores, which is expected for quality ChIP-seq data.</p>
<hr>
<p><strong>Example of Poor IDR (Cross-Factor Comparison):</strong></p>
<p>This demonstrates poor IDR results when calculated between biologically unrelated samples (CEBPA replicate vs H3K9ac replicate), shown here for illustration purposes only:</p>
<img width="1200" height="1200" alt="H3K9ac_ceb_idr_peaks txt" src="https://github.com/user-attachments/assets/1e10e020-1138-46d2-b046-de1a656dd508" />
<h2 id="3-motif-analysis-finding-dna-binding-sequences"><a class="header" href="#3-motif-analysis-finding-dna-binding-sequences">3. Motif Analysis: Finding DNA Binding Sequences</a></h2>
<h3 id="why-motif-analysis-matters"><a class="header" href="#why-motif-analysis-matters">Why Motif Analysis Matters</a></h3>
<p>Reproducible peaks answer <em>where</em> the protein binds.
Motif analysis answers <em>why</em> it binds there.</p>
<ul>
<li>Transcription factors bind <strong>specific DNA sequences</strong></li>
<li>Histone marks do <strong>not</strong> bind DNA directly</li>
<li>Motif enrichment validates biological specificity</li>
</ul>
<p>Example:</p>
<ul>
<li><strong>CEBPA:</strong> sequence-specific TF</li>
<li><strong>H3K9ac:</strong> chromatin mark, no intrinsic motif</li>
</ul>
<p>If a TF ChIP-seq lacks its expected motif, the experiment is suspect.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>You need the <strong>genome FASTA file</strong> for sequence extraction:</p>
<pre><code class="language-bash"># Download and extract genome FASTA
wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_49/GRCh38.primary_assembly.genome.fa.gz
gunzip GRCh38.primary_assembly.genome.fa.gz
</code></pre>
<h2 id="4-motif-discovery-with-homer"><a class="header" href="#4-motif-discovery-with-homer">4. Motif Discovery with HOMER</a></h2>
<p><strong>HOMER (Hypergeometric Optimization of Motif EnRichment)</strong> is the most widely used ChIP-seq motif discovery framework.</p>
<h3 id="installing-homer"><a class="header" href="#installing-homer">Installing HOMER</a></h3>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>macOS ARM64 Users:</strong> HOMER may require manual installation. Use the provided <code>install_homer.sh</code> script for streamlined setup.</p>
</blockquote>
<hr>
<h3 id="running-homer-on-idr-peaks"><a class="header" href="#running-homer-on-idr-peaks">Running HOMER on IDR Peaks</a></h3>
<pre><code class="language-bash"># Extract genomic coordinates from IDR peaks
awk '$12 &gt;= 1.3 {print $1,$2,$3}' OFS="\t" \
  idr/ceb_idr_peaks.txt &gt; idr/ceb_idr_passed.bed

# Run HOMER motif discovery
findMotifsGenome.pl \
  idr/ceb_idr_passed.bed \
  GRCh38.primary_assembly.genome.fa \
  idr/cebpa_motifs/ \
  -size 200 \
  -mask \
  -p 8
</code></pre>
<p><strong>Parameter Explanation:</strong></p>
<ul>
<li><code>idr/ceb_idr_passed.bed</code>: Input peak file (IDR-filtered peaks)</li>
<li><code>GRCh38.primary_assembly.genome.fa</code>: Genome assembly</li>
<li><code>idr/cebpa_motifs/</code>: Output directory for results</li>
<li><code>-size 200</code>: Search ±100bp around peak center (200bp total window)</li>
<li><code>-mask</code>: Mask repetitive DNA sequences</li>
<li><code>-p 8</code>: Use 8 CPU threads for parallel processing</li>
</ul>
<h3 id="interpreting-homer-results"><a class="header" href="#interpreting-homer-results">Interpreting HOMER Results</a></h3>
<p>HOMER creates an output directory with:</p>
<pre><code class="language-text">idr/cebpa_motifs/
├── homerResults.html          # Main results page (OPEN THIS)
├── knownResults.html          # Matches to known motifs
├── motif1.logo.png            # Top de novo motif
├── motif2.logo.png
└── motif1.motif               # Position weight matrix
</code></pre>
<p><strong>Example output from CEBPA analysis:</strong></p>
<img width="1477" height="84" alt="Screenshot 2025-12-22 at 2 31 56 PM" src="https://github.com/user-attachments/assets/5a40f7b3-1a11-4cc7-8405-7001aafdff35" />
<p><strong>Interpreting the results:</strong></p>
<ul>
<li><strong>Rank (1):</strong> Top-ranked motif, most strongly enriched among all detected sequences</li>
<li><strong>Motif (logo):</strong> Canonical C/EBP-family DNA-binding motif (TTGCGCAA/TTGCAT core) indicating specific TF binding</li>
<li><strong>P-value (1e−2876):</strong> Extreme overrepresentation in peaks vs background, statistically highly significant</li>
<li><strong>% of Targets (63.39%):</strong> Nearly two-thirds of peaks contain this motif, indicating coherent TF-driven peak set</li>
<li><strong>% of Background (3.43%):</strong> Rare in background regions, demonstrating strong specificity and enrichment</li>
<li><strong>STD (30.7 bp vs 64.0 bp):</strong> Motif centered near peak summits (targets) vs broadly distributed (background), supporting direct DNA binding</li>
<li><strong>Best Match (CEBPE/MA0837.1, 0.963):</strong> De novo motif matches known JASPAR CEBPE motif with high confidence</li>
<li><strong>Motif File:</strong> Provides position weight matrix for reproducibility and downstream scanning</li>
</ul>
<hr>
<h2 id="5-directory-structure-after-idr--motif-analysis"><a class="header" href="#5-directory-structure-after-idr--motif-analysis">5. Directory Structure After IDR &amp; Motif Analysis</a></h2>
<pre><code class="language-text">chipseq_tutorial/
├── macs3_results/              ← Peak files from MACS3
│   ├── ceb_ENCFF327JFG_peaks.narrowPeak
│   ├── ceb_ENCFF744SVA_peaks.narrowPeak
│   └── ...
├── idr/                        ← IDR outputs
│   ├── ceb_idr_peaks.txt       # All peaks with IDR scores
│   ├── ceb_idr_passed.bed      # Filtered peaks (IDR ≤ 0.05)
│   ├── ceb_idr.log             # IDR statistics
│   └── ceb_idr_peaks.txt.png   # Diagnostic plots
└── idr/cebpa_motifs/           ← HOMER motif results
    ├── homerResults.html       # Main results page
    ├── knownResults.html       # Known motif matches
    ├── motif1.logo.png         # Top de novo motif
    └── motif1.motif            # Position weight matrix
</code></pre>
<hr>
<h2 id="6-summary"><a class="header" href="#6-summary">6. Summary</a></h2>
<p><strong>Key Achievements:</strong></p>
<ol>
<li>Filtered 32,273 peaks → 9,468 reproducible peaks (29.3%) using IDR ≤ 0.05</li>
<li>Validated replicate concordance with diagnostic plots</li>
<li>Identified canonical C/EBP motif in 63% of peaks (HOMER)</li>
<li>Confirmed CEBPA specificity through motif enrichment</li>
</ol>
<p><strong>Quality Indicators:</strong></p>
<p><strong>Good:</strong> Strong diagonal in rank-rank plot, ~30% IDR pass rate, expected motif in &gt;50% peaks
<strong>Poor:</strong> Scattered plot, &lt;10% IDR pass rate, no motif enrichment</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> Generate normalized signal tracks (BigWig files) for genome browser visualization and create publication-quality heatmaps showing enrichment patterns around genomic features.</p>
</blockquote>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="bam-to-bigwig-visualizing-the-signal"><a class="header" href="#bam-to-bigwig-visualizing-the-signal">Bam to BigWig (Visualizing the Signal)</a></h1>
<p><code>bamCoverage</code> <code>bigWig</code> <code>normalization</code> <code>RPGC</code> <code>effective-genome-size</code> <code>visualization</code></p>
<h2 id="1-basic-concept-the-traffic-map"><a class="header" href="#1-basic-concept-the-traffic-map">1. Basic Concept (The Traffic Map)</a></h2>
<h3 id="why-bigwig"><a class="header" href="#why-bigwig">Why BigWig?</a></h3>
<p>A <strong>BAM</strong> file gives you the location of every single “car” (read) on the road. It’s massive and slow to load.</p>
<p>A <strong>BigWig</strong> file is like the <strong>Google Maps Traffic View</strong>. It doesn’t show you the individual cars; it just shows you a green, yellow, or red line indicating “Volume”.</p>
<ul>
<li><strong>Small &amp; Fast:</strong> Compact file size.</li>
<li><strong>Small &amp; Fast:</strong> Compact file size.</li>
<li><strong>Visual:</strong> Perfect for viewing on a Genome Browser (IGV/UCSC).</li>
</ul>
<hr>
<h2 id="2-requirements-effective-genome-size"><a class="header" href="#2-requirements-effective-genome-size">2. Requirements (Effective Genome Size)</a></h2>
<p>The “Effective” size is the part of the genome that is mappable.</p>
<ul>
<li><strong>Unique Regions:</strong> Easy to map.</li>
<li><strong>Repetitive Regions:</strong> Hard to map, but reads can technically align there (Ambiguous).</li>
</ul>
<p><strong>Formula 1: Total Raw Length</strong>
$$
\text{Total Genome Length} = \underbrace{\text{Effective Genome}}<em>{\text{All Mappable}} + \underbrace{\text{N-bases}}</em>{\text{Gaps/Unsequenced}}
$$</p>
<p><strong>Formula 2: Breaking Down “Effective Genome”</strong>
$$
\text{Effective Genome} = \underbrace{\text{Unique Genome}}<em>{\text{Easy}} + \underbrace{\text{Repetitive DNA}}</em>{\text{Ambiguous}}
$$</p>
<h3 id="how-we-calculated-it"><a class="header" href="#how-we-calculated-it">How we calculated it</a></h3>
<p>There are <strong>two main ways</strong> to estimate this:</p>
<h4 id="method-1-fasize-calculates-general-effective-genome"><a class="header" href="#method-1-fasize-calculates-general-effective-genome">Method 1: faSize (Calculates General Effective Genome)</a></h4>
<p>The <strong>faSize</strong> tool counts all non-N bases. This assumes that if a read aligns to a repeat, it still counts as “mapped”.</p>
<p><strong>Step 1.1: Extract chr11 and chr12</strong></p>
<pre><code class="language-bash">samtools faidx genome.fasta chr11 chr12 &gt; chr11_chr12.fasta
</code></pre>
<p><strong>Step 1.2: Get statistics</strong></p>
<pre><code class="language-bash">faSize chr11_chr12.fasta
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>268361931 bases (690373 N's 267671558 real 267671558 upper 0 lower) in 2 sequences inside 1 file
</code></pre>
<p><strong>Step 1.3: Calculate total effective size (non-N)</strong></p>
<pre><code class="language-bash">awk '{nonN = $2 - $5; sum += nonN} END {print sum}' chr11_chr11_chr12.faSize.txt
# Result: 268361931
</code></pre>
<p><strong>Result:</strong> <code>268,361,931 bp</code> (Unique + Repetitive)</p>
<h4 id="method-2-khmer-calculates-unique-effective-genome"><a class="header" href="#method-2-khmer-calculates-unique-effective-genome">Method 2: khmer (Calculates Unique Effective Genome)</a></h4>
<p>The <strong>khmer</strong> tool counts only unique k-mers. It strictly ignores repetitive zones.</p>
<p><strong>Command:</strong></p>
<pre><code class="language-bash">unique-kmers.py -k 21 chr11_chr12.fasta
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>(chip) rajaishaqnabikhan@Mac human % unique-kmers.py -k 21 chr11_chr12.fasta

|| This is the script unique-kmers.py in khmer.
|| You are running khmer version 3.0.0a3
|| You are also using screed version 1.1.3
||
|| If you use this script in a publication, please cite EACH of the following:
||
||   * MR Crusoe et al., 2015. https://doi.org/10.12688/f1000research.6924.1
||   * A. Döring et al. https://doi.org:80/10.1186/1471-2105-9-11
||   * Irber and Brown. https://doi.org/10.1101/056846
||
|| Please see http://khmer.readthedocs.io/en/latest/citations.html for details.

Estimated number of unique 21-mers in chr11_chr12.fasta: 220798375
Total estimated number of unique 21-mers: 220798375
</code></pre>
<h3 id="the-result"><a class="header" href="#the-result">The Result</a></h3>
<ul>
<li><strong>Raw length (Method 1: faSize):</strong> <code>268,361,931 bp</code> (Unique + Repetitive)</li>
<li><strong>Unique length (Method 2: khmer):</strong> <code>220,798,375 bp</code> (Unique Only)</li>
<li><strong>The Difference:</strong> <code>47,563,556 bp</code> of repetitive/unmappable DNA (Ambiguous).</li>
</ul>
<h3 id="the-decision"><a class="header" href="#the-decision">The Decision</a></h3>
<p>Which number do we use?</p>
<ul>
<li>Therefore, we must use the <strong>khmer</strong> result (<code>Unique Only</code>), because our data does not contain reads mapped to repetitive regions.</li>
</ul>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p><strong>Use this number:</strong> <code>220798375</code></p>
</blockquote>
<hr>
<h2 id="3-execution-the-converter"><a class="header" href="#3-execution-the-converter">3. Execution (The Converter)</a></h2>
<p>We use <code>bamCoverage</code> to convert BAM files into BigWig tracks. We will normalize using <strong>RPGC</strong> (Reads Per Genome Coverage) so all tracks are comparable (1x coverage scale).</p>
<h3 id="step-31-create-output-directory"><a class="header" href="#step-31-create-output-directory">Step 3.1: Create Output Directory</a></h3>
<p>Keep your workspace clean.</p>
<pre><code class="language-bash">mkdir -p bigwigs
</code></pre>
<h3 id="step-32-run-bamcoverage-loop"><a class="header" href="#step-32-run-bamcoverage-loop">Step 3.2: Run bamCoverage Loop</a></h3>
<p>We process all BAM files using our <code>sample_id.txt</code> list.</p>
<pre><code class="language-bash"># Loop through each sample ID in the text file
cat sample_id.txt | while read id; do
  
  echo "Generating BigWig for: $id"
  
  bamCoverage \
    -b encode_bam/${id}.bam \                    
    -o bigwigs/${id}.bw \                        
    --binSize 10 \                               
    --normalizeUsing RPGC \                      
    --effectiveGenomeSize 2701495761 \            
    --smoothLength 30 \                          
    --numberOfProcessors 4 

done
</code></pre>
<p><strong>What this does:</strong></p>
<ol>
<li><strong>Reads</strong> the BAM file.</li>
<li><strong>Chops</strong> the genome into 10bp bins (buckets).</li>
<li><strong>Counts</strong> reads in each bin.</li>
<li><strong>Normalizes</strong> the count so 1.0 = 1x genome coverage.</li>
<li><strong>Smooths</strong> the signal (averaging neighbors) to make the peaks look cleaner.</li>
<li><strong>Saves</strong> the result as a <code>.bw</code> file.</li>
</ol>
<hr>
<h2 id="4-fine-tuning-under-the-hood"><a class="header" href="#4-fine-tuning-under-the-hood">4. Fine Tuning (Under the Hood)</a></h2>
<h3 id="41-bin-size-resolution"><a class="header" href="#41-bin-size-resolution">4.1 Bin Size (Resolution)</a></h3>
<ul>
<li><strong>Concept:</strong> Think of this as the <strong>Resolution</strong> of your image.</li>
<li><strong>Small Bin (10bp):</strong> “HD” resolution. You see every tiny peak, but the file is larger and slower to compute.</li>
<li><strong>Large Bin (100bp):</strong> “SD” resolution. Good for zooming out and looking at broad trends. Faster to process.</li>
<li><strong>Decision:</strong> For transcription factors (sharp peaks), 10bp is great. For broad histone marks (H3K27me3), 50-100bp is often sufficient. We use <strong>10bp</strong> here for high detail.</li>
</ul>
<h3 id="42-smoothing-blurring-the-photo"><a class="header" href="#42-smoothing-blurring-the-photo">4.2 Smoothing (Blurring the Photo)</a></h3>
<ul>
<li><strong>Concept:</strong> Smoothing averages the signal of nearby bins to reduce “jumpy” noise.</li>
<li><strong>Why?</strong> Raw sequencing data can be pixelated. Smoothing applies a slight blur to make the biological signal (the hill) stand out against the background noise (the grass).</li>
<li><strong>Our Setting:</strong> <code>--smoothLength 30</code>. This averages the signal over a 30bp window.</li>
</ul>
<h3 id="43-normalization-the-currency-exchange"><a class="header" href="#43-normalization-the-currency-exchange">4.3 Normalization (The Currency Exchange)</a></h3>
<p>Samples have different sequencing depths.</p>
<ul>
<li><strong>Sample A:</strong> 40 million reads (Rich)</li>
<li><strong>Sample B:</strong> 20 million reads (Poor)</li>
</ul>
<p>If we don’t fix this, Sample A will look huge just because it has more money (reads). <strong>Normalization</strong> puts everyone on the same currency.</p>
<ul>
<li><strong>RPGC (Reads Per Genome Coverage):</strong> <em>Preferred for ChIP-seq.</em>
<ul>
<li><strong>Logic:</strong> “What would this signal look like if we had exactly <strong>1x coverage</strong> of the genome?”</li>
<li><strong>Why:</strong> It creates a standardized “Currency” (1x coverage) that makes biological sense. A value of “5.0” in the track means “5 times more reads than random background”.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<ol>
<li><strong>Input:</strong> BAM files (<code>encode_bam/</code>).</li>
<li><strong>Action:</strong> <code>bamCoverage</code> with <strong>RPGC</strong> normalization.</li>
<li><strong>Output:</strong> BigWig files (<code>bigwigs/</code>) ready for IGV visualization.</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> Now that we have our signals (BigWigs) and our QC (Fingerprints) done, we are ready to call peaks! (Wait, technically we usually call peaks <em>before</em> or <em>parallel</em> to visualization, but viewing tracks helps confirm peak calls).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="visualization-the-camera-angles"><a class="header" href="#visualization-the-camera-angles">Visualization (The Camera Angles)</a></h1>
<p><code>computeMatrix</code> <code>plotProfile</code> <code>plotHeatmap</code> <code>TSS-enrichment</code> <code>gene-body-profile</code> <code>visualization</code></p>
<h2 id="1-basic-concept-camera-modes"><a class="header" href="#1-basic-concept-camera-modes">1. Basic Concept (Camera Modes)</a></h2>
<p>We want to visualize the “Average” pattern of our protein across all genes. To do this, we need to choose our <strong>Camera Mode</strong>:</p>
<h3 id="1-portrait-mode-reference-point"><a class="header" href="#1-portrait-mode-reference-point">1. Portrait Mode (Reference-Point)</a></h3>
<ul>
<li><strong>Focus:</strong> One specific point (e.g., the Transcription Start Site, <strong>TSS</strong>).</li>
<li><strong>Action:</strong> We stand at the TSS and look 4kb upstream and 4kb downstream.</li>
<li><strong>Use Case:</strong> Great for seeing promoter activity (<strong>H3K9ac</strong>, Transcription Factors).</li>
</ul>
<h3 id="2-panorama-mode-scale-regions"><a class="header" href="#2-panorama-mode-scale-regions">2. Panorama Mode (Scale-Regions)</a></h3>
<ul>
<li><strong>Focus:</strong> The entire gene body.</li>
<li><strong>Action:</strong> Since genes are different lengths (short vs long), we stretch or compress them all to fit the same “frame” (e.g., 5000bp).</li>
<li><strong>Use Case:</strong> Great for seeing broad marks that cover the whole gene (<strong>H3K27me3</strong>, H3K36me3).</li>
</ul>
<p><strong>The Process:</strong></p>
<ol>
<li><strong>Prepare the Map (BED):</strong> Define where the genes are.</li>
<li><strong>Create the Blueprint (Matrix):</strong> <code>computeMatrix</code> calculates the numbers.</li>
<li><strong>Take the Photo (Plot):</strong> <code>plotHeatmap</code> or <code>plotProfile</code> draws the picture.</li>
</ol>
<hr>
<h2 id="2-requirements-the-files"><a class="header" href="#2-requirements-the-files">2. Requirements (The Files)</a></h2>
<p>We need:</p>
<ol>
<li><strong>BigWig Files:</strong> Generated in Tutorial 12 (in <code>bigwigs/</code>).</li>
<li><strong>BED Files:</strong> From Reference Annotation (Tutorial 01).
<ul>
<li><code>tss.bed</code> (Start sites only)</li>
<li><code>genes.bed</code> (Full gene bodies)</li>
</ul>
</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Output Directory:</strong> All results will go into <code>bw_plot/</code> to keep things organized.</p>
</blockquote>
<hr>
<h2 id="3-execution-the-blueprint"><a class="header" href="#3-execution-the-blueprint">3. Execution (The Blueprint)</a></h2>
<p>We will calculate the matrices using two simple commands.</p>
<h3 id="step-31-portrait-mode-tss-matrix"><a class="header" href="#step-31-portrait-mode-tss-matrix">Step 3.1: Portrait Mode (TSS Matrix)</a></h3>
<p>This command calculates the signal ±4kb around the TSS.</p>
<pre><code class="language-bash">mkdir -p bw_plot

# Calculate signals around TSS
computeMatrix reference-point \
    --referencePoint TSS \
    -b 4000 -a 4000 \
    -R tss.bed \
    -S bigwigs/*.bw \
    --skipZeros \
    -o bw_plot/matrix_all_bw_TSS.gz \
    --binSize 1000 \
    --numberOfProcessors 4
</code></pre>
<h3 id="step-32-panorama-mode-gene-body-matrix"><a class="header" href="#step-32-panorama-mode-gene-body-matrix">Step 3.2: Panorama Mode (Gene Body Matrix)</a></h3>
<p>This command stretches all genes to 5kb to compare them side-by-side.</p>
<pre><code class="language-bash"># Calculate signals across entire gene bodies
computeMatrix scale-regions \
    -R genes.bed \
    -S bigwigs/*.bw \
    --regionBodyLength 5000 \
    -b 1000 -a 1000 \
    --binSize 1000 \
    --skipZeros \
    -o bw_plot/matrix_all_bw_scalar.gz \
    --numberOfProcessors 4
</code></pre>
<hr>
<h2 id="4-plotting-the-photo"><a class="header" href="#4-plotting-the-photo">4. Plotting (The Photo)</a></h2>
<p>Now that we have the “Blueprints” (matrices), we can develop the actual images.</p>
<h3 id="41-plot-profiles-line-graphs"><a class="header" href="#41-plot-profiles-line-graphs">4.1 Plot Profiles (Line Graphs)</a></h3>
<p>This shows the <em>Average</em> signal across all genes.</p>
<pre><code class="language-bash"># 1. TSS Profile (Portrait)
plotProfile \
  -m bw_plot/matrix_all_bw_TSS.gz \
  -out bw_plot/profile_TSS.pdf \
  --perGroup \
  --plotTitle "TSS Enrichment Profile" \
  --dpi 600

# 2. Gene Body Profile (Panorama)
plotProfile \
  -m bw_plot/matrix_all_bw_scalar.gz \
  -out bw_plot/profile_Body.pdf \
  --perGroup \
  --plotTitle "Gene Body Enrichment Profile" \
  --dpi 600
</code></pre>
<h3 id="42-plot-heatmaps-rich-detail"><a class="header" href="#42-plot-heatmaps-rich-detail">4.2 Plot Heatmaps (Rich Detail)</a></h3>
<p>This shows the signal for <em>Every Single Gene</em> stacked on top of each other.</p>
<pre><code class="language-bash"># Heatmap for TSS
plotHeatmap \
  -m bw_plot/matrix_all_bw_TSS.gz \
  -out bw_plot/heatmap_TSS.pdf \
  --colorMap jet \
  --missingDataColor "#FFF6EB" \
  --refPointLabel "TSS" \
  --dpi 600

# Heatmap for Gene Body
plotHeatmap \
  -m bw_plot/matrix_all_bw_scalar.gz \
  -out bw_plot/heatmap_genebody.pdf \
  --colorMap jet \
  --missingDataColor "#FFF6EB" \
  --refPointLabel "Gene Start" \
  --dpi 600
</code></pre>
<h3 id="43-advanced-k-means-clustering"><a class="header" href="#43-advanced-k-means-clustering">4.3 Advanced: K-means Clustering</a></h3>
<p>This groups genes into clusters based on their signal patterns (useful for finding distinct gene classes).</p>
<pre><code class="language-bash">plotProfile \
  -m bw_plot/matrix_all_bw_scalar.gz \
  --perGroup \
  --kmeans 2 \
  --plotType heatmap \
  -out bw_plot/profile_kmeans_heatmap.pdf
</code></pre>
<hr>
<h2 id="5-reading-the-results"><a class="header" href="#5-reading-the-results">5. Reading the Results</a></h2>
<h3 id="51-the-tss-profile-portrait"><a class="header" href="#51-the-tss-profile-portrait">5.1 The TSS Profile (Portrait)</a></h3>
<p>This tells us about <strong>Promoter Activity</strong>.</p>
<img width="900" height="271" alt="Screenshot 2025-12-15 at 7 10 31 PM" src="https://github.com/user-attachments/assets/294305c8-a488-45b8-bf90-d1c0a0d6a1be" />
<ul>
<li><strong>Input (Background):</strong> Flat line (~1.2-1.5). No enrichment. This is good quality control.</li>
<li><strong>H3K9ac (Active Mark):</strong> <strong>Huge spike</strong> right at the TSS (reaching ~12-25!). This confirms H3K9ac is strongly associated with active promoters.</li>
<li><strong>H3K27me3 (Repressive Mark):</strong> Broad, lower hill (~2.5-3.0). It doesn’t spike at the TSS but sits broadly around it.</li>
<li><strong>CEBPA (Factor):</strong> Small but distinct bump at the TSS (~1.5). Transcription factors bind specific spots, so the average signal is lower than histone marks but still distinct from input.</li>
</ul>
<h3 id="52-the-gene-body-profile-panorama"><a class="header" href="#52-the-gene-body-profile-panorama">5.2 The Gene Body Profile (Panorama)</a></h3>
<p>This tells us about <strong>Domain Structure</strong>.</p>
<img width="1022" height="323" alt="Screenshot 2025-12-10 at 12 14 14 PM" src="https://github.com/user-attachments/assets/0c10ed9f-6ff9-43a1-82d6-0c029973c56f" />
<ul>
<li><strong>H3K9ac:</strong> Spike at the start (TSS), then rapid drop. It’s a “Starting Gun” mark.</li>
<li><strong>H3K27me3:</strong> Stays elevated across the <strong>entire gene body</strong>, slowly decaying. It’s a “Blanket” mark that covers the whole region to silence it.</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Mark</th><th style="text-align: left">Portrait (TSS)</th><th style="text-align: left">Panorama (Gene Body)</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><strong>Input</strong></td><td style="text-align: left">Flat.</td><td style="text-align: left">Flat.</td></tr>
<tr><td style="text-align: left"><strong>H3K9ac</strong></td><td style="text-align: left"><strong>Sharp Spike</strong></td><td style="text-align: left">Spike then Drop.</td></tr>
<tr><td style="text-align: left"><strong>H3K27me3</strong></td><td style="text-align: left">Broad Hill</td><td style="text-align: left"><strong>Broad Blanket</strong> (Entire Gene)</td></tr>
</tbody>
</table>
</div>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><strong>Up Next:</strong> We have visualized the signals and confirmed they look biologically correct. Now, finally, we will use <strong>MACS2</strong> to mathematically identify the exact genomic coordinates of these peaks.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="annotation--visualization"><a class="header" href="#annotation--visualization">Annotation &amp; Visualization</a></h1>
<h2 id="introduction-decoding-the-map"><a class="header" href="#introduction-decoding-the-map">Introduction: Decoding the Map</a></h2>
<p>You have successfully defined your <strong>Peaks</strong> (GPS coordinates of protein binding). But coordinates alone don’t tell a biological story.
<strong>Annotation</strong> is the process of cross-referencing these coordinates with a <strong>Gene Map</strong> (GTF) to answer:</p>
<ul>
<li>“Does my protein bind to Promoters?”</li>
<li>“Is it hiding in Intergenic Deserts?”</li>
<li>“Does it prefer Exons or Introns?”</li>
</ul>
<p>Below is the full interactive report generated by <strong>ChIPseeker</strong>.</p>
<hr><iframe src="ChIP-seq_analysis_with_Chipseeker.html" width="100%" height="800px" style="border:none;"></iframe>
<hr>
<h2 id="how-to-interpret-the-figures-reference-guide"><a class="header" href="#how-to-interpret-the-figures-reference-guide">How to Interpret the Figures (Reference Guide)</a></h2>
<p>Since the report above contains many plots, here is a guide on how to read the most important ones:</p>
<h3 id="1-the-tss-heatmap-portrait-mode"><a class="header" href="#1-the-tss-heatmap-portrait-mode">1. The TSS Heatmap (Portrait Mode)</a></h3>
<ul>
<li><strong>What it shows:</strong> The binding intensity ±3000bp around the Transcription Start Site (TSS).</li>
<li><strong>How to read it:</strong>
<ul>
<li><strong>Vertical Axis:</strong> Each line is one gene.</li>
<li><strong>Horizontal Axis:</strong> Center is TSS. Left is Upstream, Right is Downstream.</li>
<li><strong>Key Insight:</strong> A dark vertical stripe at the center (0) means your protein is a <strong>Strong Promoter Binder</strong> (like H3K9ac or Transcription Factors). A broad cloud means it’s a domain mark (like H3K27me3).</li>
</ul>
</li>
</ul>
<h3 id="2-the-average-profile-plot"><a class="header" href="#2-the-average-profile-plot">2. The Average Profile Plot</a></h3>
<ul>
<li><strong>What it shows:</strong> The average signal across all genes, summarized as a line graph.</li>
<li><strong>How to read it:</strong>
<ul>
<li><strong>Sharp Spike at 0:</strong> Confirms precise positioning at promoters.</li>
<li><strong>Dip (Valley) at 0:</strong> Indicates the protein binds <em>around</em> the TSS (like nucleosomes) but leaves the start site open.</li>
</ul>
</li>
</ul>
<h3 id="3-the-genomic-annotation-barplot"><a class="header" href="#3-the-genomic-annotation-barplot">3. The Genomic Annotation Barplot</a></h3>
<ul>
<li><strong>What it shows:</strong> Where your peaks land (Promoter vs. Intron vs. Distal Intergenic).</li>
<li><strong>How to read it:</strong>
<ul>
<li><strong>High Promoter Fraction (&gt;50%):</strong> Your protein regulates genes directly (e.g., TFs, active histones).</li>
<li><strong>High Distal Intergenic:</strong> Your protein might be an Enhancer-binding factor.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-how-we-built-this-book"><a class="header" href="#appendix-how-we-built-this-book">Appendix: How We Built This Book</a></h1>
<p>This tutorial documents the exact steps taken to turn our loose collection of tutorial files into this structured <strong>mdbook</strong>.</p>
<h2 id="1-getting-started"><a class="header" href="#1-getting-started">1. Getting Started</a></h2>
<p>The very first step is to get the code and set up the book tool.</p>
<h3 id="step-1-clone-the-repository"><a class="header" href="#step-1-clone-the-repository">Step 1: Clone the Repository</a></h3>
<p>We started by downloading the tutorial material from GitHub:</p>
<pre><code class="language-bash">git clone https://github.com/your-username/Chipseq_analysis_tutorial.git
cd Chipseq_analysis_tutorial
</code></pre>
<h3 id="step-2-install-mdbook"><a class="header" href="#step-2-install-mdbook">Step 2: Install mdbook</a></h3>
<p>On macOS (using Homebrew):</p>
<pre><code class="language-bash">brew install mdbook
</code></pre>
<h3 id="step-3-initialize-the-book"><a class="header" href="#step-3-initialize-the-book">Step 3: Initialize the Book</a></h3>
<p>We initialized a new book structure inside our folder:</p>
<pre><code class="language-bash">mdbook init my-first-book
cd my-first-book
</code></pre>
<ul>
<li>This created the <code>book.toml</code> configuration file and the <code>src/</code> directory.</li>
</ul>
<hr>
<h2 id="2-organizing-the-content"><a class="header" href="#2-organizing-the-content">2. Organizing the Content</a></h2>
<p>We moved our existing tutorial files into this new structure.</p>
<h3 id="file-migration"><a class="header" href="#file-migration">File Migration</a></h3>
<ul>
<li><strong>Moved:</strong> All markdown files (<code>00_setup_environment.md</code> through <code>pipeline_tutorial_simple.md</code>) were moved into the <code>src/</code> directory.</li>
<li><strong>Excluded:</strong> <code>02_bash_automation.ipynb</code> and the RMarkdown file remained in the root (for now) as they needed conversion.</li>
</ul>
<h3 id="configuration-summarymd"><a class="header" href="#configuration-summarymd">Configuration (<code>SUMMARY.md</code>)</a></h3>
<p>We updated <code>src/SUMMARY.md</code> to define the order of chapters in the sidebar:</p>
<pre><code class="language-markdown"># Summary
- [Setup Environment](./00_setup_environment.md)
...
</code></pre>
<hr>
<h2 id="3-the-notebook-problem-ipynb"><a class="header" href="#3-the-notebook-problem-ipynb">3. The “Notebook” Problem (.ipynb)</a></h2>
<p><strong>Issue:</strong> <code>mdbook</code> does not natively support Jupyter Notebooks.
<strong>Solution:</strong> Convert them to standard Markdown.</p>
<p><strong>Command Used:</strong></p>
<pre><code class="language-bash"># Convert the notebook to markdown
jupyter nbconvert --to markdown 02_bash_automation.ipynb

# Move the result to src
mv 02_bash_automation.md src/
</code></pre>
<hr>
<h2 id="4-the-chipseeker-problem-html-reports"><a class="header" href="#4-the-chipseeker-problem-html-reports">4. The “ChIPseeker” Problem (HTML Reports)</a></h2>
<p><strong>Issue:</strong> We had an RMarkdown report (<code>ChIP-seq_analysis_with_Chipseeker.html</code>) with interactive plots. Markdown cannot display dynamic HTML directly, but we wanted to keep the interactivity.</p>
<p><strong>Solution:</strong> The Hybrid Wrapper (Iframe).</p>
<ol>
<li>
<p><strong>Move the HTML:</strong> The <code>.html</code> file <strong>must</strong> be inside <code>src/</code> so it gets copied to the final website.</p>
<pre><code class="language-bash">mv ChIP-seq_analysis_with_Chipseeker.html src/
</code></pre>
</li>
<li>
<p><strong>Create a Wrapper File:</strong> We created <code>src/14_chipseeker_annotation.md</code>.</p>
</li>
<li>
<p><strong>Embed it:</strong> We used an HTML <code>&lt;iframe&gt;</code> tag inside the markdown file:</p>
<pre><code class="language-html"># Annotation Tutorial

(Normal text explaining the science goes here...)

&lt;!-- This window shows the other file --&gt;
&lt;iframe src="ChIP-seq_analysis_with_Chipseeker.html" width="100%" height="800px" style="border:none;"&gt;&lt;/iframe&gt;
</code></pre>
</li>
</ol>
<hr>
<h2 id="5-building--serving"><a class="header" href="#5-building--serving">5. Building &amp; Serving</a></h2>
<p>To see the book, we run:</p>
<pre><code class="language-bash">mdbook serve --open
</code></pre>
<p>This serves the website at <code>http://localhost:3000</code> and auto-updates whenever we save a file.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="custom-42beaf49.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
